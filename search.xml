<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift中的派发机制]]></title>
    <url>%2F2019%2F09%2F15%2FSwift%E4%B8%AD%E7%9A%84%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Swift中的函数调用有很多奇怪的行为, 比如:案例112345678910111213141516protocol Runnable &#123; &#125;extension Runnable &#123; func run() &#123; print("run") &#125;&#125;class Human: Runnable &#123; func run() &#123; print("human run") &#125;&#125;let r: Runnable = Human()r.run() // expected prints "human run", but prints "run" &lt;- Unexpected! 这些反直觉的案例就事实存在于Swift中, 要想清晰的明白它们发生的原因, 就必须缕清它们背后的调用机制–函数派发. 函数派发就是程序判断使用哪种途径去调用一个函数的机制. 了解派发机制对于写出高性能的代码来说很有必要, 而且也能够解释很多Swift里奇怪的行为. 派发方式编译型语言有三种基础的派发方式, 分别是: 直接派发(Direct Dispatch), 函数表派发(Table Dispatch) 和 消息机制派发(Message Dispatch). 大多数语言都会支持 直接派发和函数表派发, 如Java和C++. 而Objective-C则总是使用消息机制(objc_msgSend)派发. 而Swift中三种都支持. 直接派发 (Direct Dispatch)直接派发是最快的, 不止是因为需要调用的指令集会更少, 并且编译器还能够有很大的优化空间, 例如函数内联等. 直接派发也称为静态调用. 然而, 对于编程来说直接调用也是最大的局限, 而且因为缺乏动态性所以没办法支持继承. 函数表派发 (Table Dispatch)函数表派发是编译型语言实现动态行为最常见的实现方式. 函数表使用了一个数组来存储类声明的每一个函数的指针. 大部分语言(如C++)把这个称为虚函数表, 而在Swift中将其称为Witness Table(目击表), 每一个类都会维护一个函数表, 里面记录着类所有的函数, 如果父类函数被 override 的话, 表里面只会保存被 override 之后的函数. 一个子类新添加的函数, 都会被插入到这个数组的最后. 运行时会根据这一个表去决定实际要被调用的函数. 这种基于数组的实现, 缺陷在于函数表无法拓展. 子类会在虚数函数表的最后插入新的函数, 没有位置可以让 extension 安全地插入函数. 消息机制派发 (Message Dispatch)消息机制是调用函数最动态的方式. 比如可以通过method swizzling或者isa swizzling来动态修改方法的实现和对象的继承关系, 从而实现自定义派发.而当一个消息被派发, 运行时会顺着类的继承关系向上查找应该被调用的函数. Swift的派发机制那么Swift是如何糅合这三种派发方式的呢? Swift的文档中并没有具体写明成体系的机制. 而通过测试和了解, Swift的派发机制是通过以下四种因素来制约: 函数声明的位置(Location Matters) 调用者(引用)的类型(Reference Type Matters) 特定的派发行为(Specifying Dispatch Behavior) 显式地优化(Visibility Optimizations) 具体的细节这篇文章已经讲述的非常好,就不做赘述. 最终可以通过一张表来总结: 如果在开发过程中,错误的混合了这几种分派方式,就可能出现意料之外的结果甚至是Bug. 拿案例1来说明, Runnable的run方法声明在Extension中, 所以只要使用了Runnable这一类型的调用者, 都是采用直接派发, 直接调用了Runnable的run方法. 同样,如果我们将案例1的run方法的声明位置变化一下:12345678protocol Runnable &#123; func run()&#125;...let r: Runnable = Human()r.run() // prints "human run" 另外在Swift4.0之前的版本, 还存在这个问题SR-923.我将其引申为一个较为清晰的版本:12345678910111213141516171819class Person: NSObject &#123; func sayHi() &#123; print("Hello") &#125;&#125;func greetings(person: Person) &#123; person.sayHi()&#125;greetings(person: Person()) // prints 'Hello'class MisunderstoodPerson: Person &#123;&#125;extension MisunderstoodPerson &#123; override func sayHi() &#123; print("No one gets me.") &#125;&#125;greetings(person: MisunderstoodPerson()) // prints 'Hello' 这也是由于NSObject的extension是使用的Message dispatch，而Initial Declaration使用的是Table dispath. extension重写的方法添加在了Message dispatch内,没有修改函数表,函数表内还是父类的方法,故会执行父类方法. 想在extension重写方法，需要标明dynamic来使用Message dispatch.不过Swift已经修复了这个Bug, 现在extension中不允许重写父类的任何函数了. 其他我们继续更改案例1:12345678910111213141516171819protocol Runnable &#123; func run()&#125;extension Runnable &#123; func run() &#123; print("run") &#125;&#125;class Human: Runnable &#123; &#125;class Man: Human &#123; func run() &#123; print("man run") &#125;&#125; 然后测试12let r: Runnable = Man.init()r.run() // prints "run" 咦 怎么会这样呢?断点打在r.run()上, 进入反汇编进行查看, 发现这个run 是被直接call了一个地址0x100001980, 而不是读取存在容器中的Protocol Witness Table(协议目击表)中的某个函数地址, 这是被直接派发调用的… swift的bug讨论处也有相关的问题提出 SR-103 讨论中大多数人认为 man的run函数并没有绑定到他自己的协议目击表中, 于是我对案例测试代码修改:12let r = Man.init()(r as Runnable).run() // prints "run" 进入反汇编查看, 发现run确实是通过读取协议目击表相关地址来调用的:在此断点下 我们读取下 r13寄存器的内容, 也就是调用__swift_project_boxed_opaque_existential_1这个函数的返回值:12345678// 读取r13寄存器内容(lldb) re r r13 r13 = 0x00007ffeefbff590// 读取 0x00007ffeefbff590 内存中的值 (5个, 16进制, 8字节)(lldb) x/5xg 0x00007ffeefbff5900x7ffeefbff590: 0x000000010217b990 0x00000000000000000x7ffeefbff5a0: 0x0000000000000000 0x00000001000022a80x7ffeefbff5b0: 0x0000000100002060 可以看出0x00007ffeefbff590也就是存在容器, 其中前8个字节存储的是我们创建的man对象的指针地址.0x7ffeefbff5a8存储的是man的metadata的地址.123456789101112(lldb) di -s 0x00000001000022a8swift_assmbly`type metadata for swift_assmbly.Man: 0x1000022a8 &lt;+0&gt;: jo 0x1000022cc ; type metadata for swift_assmbly.Man + 36 0x1000022aa &lt;+2&gt;: addb %al, (%rax) 0x1000022ac &lt;+4&gt;: addl %eax, (%rax) 0x1000022ae &lt;+6&gt;: addb %al, (%rax) 0x1000022b0 &lt;+8&gt;: sbbb %ah, (%rdx) 0x1000022b2 &lt;+10&gt;: addb %al, (%rax) 0x1000022b4 &lt;+12&gt;: addl %eax, (%rax) 0x1000022b6 &lt;+14&gt;: addb %al, (%rax) 0x1000022b8 &lt;+16&gt;: addb %ah, (%rdi,%rsi,4) 0x1000022bb &lt;+19&gt;: outsb (%rsi), %dx 而最后8个字节, 存储的就是Protocol Witness Table的地址12(lldb) di -s 0x0000000100002060swift_assmbly`protocol witness table for swift_assmbly.Human : swift_assmbly.Runnable in swift_assmbly: 而最终调用的是什么呢? 我们读取下rax寄存器的地址12(lldb) re r rax rax = 0x0000000100002060 swift_assmbly`protocol witness table for swift_assmbly.Human : swift_assmbly.Runnable in swift_assmbly 发现存储的就是协议目击表的地址.而 *0x8(%rax) 就是 rax存储地址+8个字节后所指向的空间的地址, 也就是最后函数调用的地址. 我们顺着打印下:1234567891011121314151617// %rax + 8 = 0x100002060 + 8 = 0x100002068(lldb) x/1xg 0x1000020680x100002068: 0x0000000100001a40(lldb) di -s 0x0000000100001a40swift_assmbly`protocol witness for Runnable.run() in conformance Human: 0x100001a40 &lt;+0&gt;: pushq %rbp 0x100001a41 &lt;+1&gt;: movq %rsp, %rbp 0x100001a44 &lt;+4&gt;: callq 0x100001870 ; (extension in swift_assmbly):swift_assmbly.Runnable.run() -&gt; () at main.swift:16 0x100001a49 &lt;+9&gt;: popq %rbp 0x100001a4a &lt;+10&gt;: retq 0x100001a4b &lt;+11&gt;: nopl (%rax,%rax)swift_assmbly`Man.run(): 0x100001a50 &lt;+0&gt;: pushq %rbp 0x100001a51 &lt;+1&gt;: movq %rsp, %rbp 0x100001a54 &lt;+4&gt;: pushq %r13 0x100001a56 &lt;+6&gt;: subq $0x38, %rsp 发现就是定义在Runnable Extension中的run函数的地址, 而在它下面我们也发现了Man自己实现的run函数地址. 所以Man的run并非没有注册进协议目击表, 只是没有被正确的调用. 参考资料【基本功】深入剖析Swift性能优化深入理解 Swift 派发机制Method Dispatch in Swiftswift/lib/IRGen/ProtocolInfo.h]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu使用Shadowsocks及Privoxy配置代理访问外网]]></title>
    <url>%2F2019%2F08%2F29%2Fubuntu%E4%BD%BF%E7%94%A8Shadowsocks%E5%8F%8APrivoxy%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91%2F</url>
    <content type="text"><![CDATA[Shadowsocks安装(已安装略过)下载get-pip文件1wget https://bootstrap.pypa.io/get-pip.py 安装shadowsocks12python get-pip.pypip install shadowsocks shadowsocks配置文件1sudo vim /etc/shadowsocks.json 123456789&#123; "server":"your.server.ip","local_address": "127.0.0.1", "local_port":1081, "server_port":yourserver_port, "password":"yourpasswd", "timeout":300, "method":"aes-256-cfb"&#125; 启动shadowsock客户端1sslocal -c /etc/shadowsocks.json -d start 停止shadowsock客户端1sslocal -c /etc/shadowsocks.json -d stop 由于shadowsocks是socket5代理，在shell里发起的请求只能使用http/https代理，所以需要安装privoxy代理，来把http请求转发给shadowsocks. Privoxy安装12sudo apt-get updatesudo apt-get install privoxy privoxy配置1vim /etc/privoxy/config 注释掉: listen-address [::1]:8118 1#listen-address [::1]:8118 最后一行添加, 注意最后的端口需要跟shadowsocks中配置的相吻合:1forward-socks5 / 127.0.0.1:1081 . 启动1systemctl restart privoxy 环境变量在~/.bashrc或者~/.zshrc中配置:12alias proxy='export http_proxy=127.0.0.1:8118;export https_proxy=127.0.0.1:8118;export ftp_proxy=127.0.0.1:8118'alias unproxy='unset http_proxy https_proxy ftp_proxy' 验证启动ss1sslocal -c /etc/shadowsocks.json -d start 启动privoxy1systemctl restart privoxy 测试123456789101112131415161718192021222324252627282930// 开启➜ ~ proxy➜ ~ curl ip.gsCurrent IP / 当前 IP: **.**.**.**ISP / 运营商: **.**City / 城市: Los Angeles CaliforniaCountry / 国家: United StatesIP.GS is now IP.SB, please visit https://ip.sb/ for more information. / IP.GS 已更改为 IP.SB ，请访问 https://ip.sb/ 获取更详细 IP 信息！Please join Telegram group https://t.me/sbfans if you have any issues. / 如有问题，请加入 Telegram 群 https://t.me/sbfans /\_/\=( °w° )= ) ( // (__ __)//// 关闭➜ ~ unproxy➜ ~ curl ip.gsCurrent IP / 当前 IP: **.**.**.**ISP / 运营商: tencent.com ChinaTelecomCity / 城市: Beijing BeijingCountry / 国家: ChinaIP.GS is now IP.SB, please visit https://ip.sb/ for more information. / IP.GS 已更改为 IP.SB ，请访问 https://ip.sb/ 获取更详细 IP 信息！Please join Telegram group https://t.me/sbfans if you have any issues. / 如有问题，请加入 Telegram 群 https://t.me/sbfans /\_/\=( °w° )= ) ( // (__ __)//]]></content>
      <tags>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用fastlane交付你的应用]]></title>
    <url>%2F2019%2F08%2F27%2F%E4%BD%BF%E7%94%A8fastlane%E4%BA%A4%E4%BB%98%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[你是否还在忍受打包时电脑风扇嗡嗡作响的苦恼, 还在”享受”MacOS菊花转起来的微妙, 是否陷入了jenkins的泥沼中止步不前? – fastlane, (私认为)一款市面上最好的打包分发工具, 足以带你脱离苦海. Why fastlane? fastlane 🚀 每次发包, 省时省力 ✨ 方便的集成你先有的工具和服务, 同时自己囊括了400多个工具. 📖 基于MIT开源 🎩 几分钟之内就可以部署 ⚒ 在你自己的机器上运行. 👻 集成了所有的CI系统. 🖥 支持iOS、 MacOS、 Android app. 🔧 基于需求 自行扩展, 不需要依赖任何东西. 💭 一行fastlane走天下, 其他指令全都不需要. 🚢 可在其他任何设备甚至是CI服务上部署. 开始搭建具体的搭建可以参考官方文档, https://docs.fastlane.tools/, 本篇只记录一些细节坑点.选择模式时选中3, 这样会走拉取iTunes Connect中 app信息的流程.12345[11:39:03]: What would you like to use fastlane for?1. 📸 Automate screenshots2. 👩‍✈️ Automate beta distribution to TestFlight3. 🚀 Automate App Store distribution4. 🛠 Manual setup - manually setup your project to automate your tasks 此时询问你是否允许 fastlane来管理你iTunes Connect app的元数据, 包括一些 app描述, 关键词, 以及截图等等. 建议允许123456[11:43:52]: Would you like to have fastlane manage your app's metadata?[11:43:52]: If you enable this feature, fastlane will download your existing metadata and screenshots.[11:43:52]: This way, you'll be able to edit your app's metadata in local `.txt` files.[11:43:52]: After editing the local `.txt` files, just run fastlane and all changes will be pushed up.[11:43:52]: If you don't want to use this feature, you can still use fastlane to upload and distribute new builds to the App Store[11:43:52]: Would you like fastlane to manage your app's metadata? (y/n) 执行完这些步骤之后, 就会发现项目目录下产生了一个fastlane的文件夹, 里面的结构是这样的:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051.├── Appfile├── Deliverfile├── Fastfile├── metadata│ ├── app_icon.jpg│ ├── copyright.txt│ ├── primary_category.txt│ ├── primary_first_sub_category.txt│ ├── primary_second_sub_category.txt│ ├── review_information│ │ ├── demo_password.txt│ │ ├── demo_user.txt│ │ ├── email_address.txt│ │ ├── first_name.txt│ │ ├── last_name.txt│ │ ├── notes.txt│ │ └── phone_number.txt│ ├── secondary_category.txt│ ├── secondary_first_sub_category.txt│ ├── secondary_second_sub_category.txt│ ├── trade_representative_contact_information│ │ ├── address_line1.txt│ │ ├── address_line2.txt│ │ ├── address_line3.txt│ │ ├── city_name.txt│ │ ├── country.txt│ │ ├── email_address.txt│ │ ├── first_name.txt│ │ ├── is_displayed_on_app_store.txt│ │ ├── last_name.txt│ │ ├── phone_number.txt│ │ ├── postal_code.txt│ │ ├── state.txt│ │ └── trade_name.txt│ └── zh-Hans│ ├── apple_tv_privacy_policy.txt│ ├── description.txt│ ├── keywords.txt│ ├── marketing_url.txt│ ├── name.txt│ ├── privacy_url.txt│ ├── promotional_text.txt│ ├── release_notes.txt│ ├── subtitle.txt│ └── support_url.txt└── screenshots ├── README.txt └── zh-Hans ├── ....png └── ....png FastFile就是存放我们自定义的指令的地方, 我们cat下FastFile, 发现fastlane已经基于我们之前的选择, 自动生成了打包上传到appstore的lane:12345678910default_platform(:ios)platform :ios do desc "Push a new release build to the App Store" lane :release do build_app(workspace: "VoiceOfGod.xcworkspace", scheme: "VoiceOfGod") upload_to_app_store endend 证书管理神器Match我个人在打包的时候为了避免开发机卡顿 造成效率下降, 所以打包都是在一台mac mini上进行的, 用之前的路数, 需要将开发机的证书导出p12和描述文件 在mini上按照, 即可保证正常.但是难受的是 每次证书更改/描述文件更新时(例如添加adhoc设备) 就需要两边一起更新, 虽然Xcode现在支持在其内部直接下载, 但是有没有办法可以更省心省力呢? 答案呼之欲出, 这便是 fastlane中著名的action Match 工作原理其实match工具的核心很简单,就是自动创建一套证书与Profile文件.然后通过Git托管这些文件.在共享机器上面通过下载并把证书装到机器上面. 初始化在项目目录下执行1fastlane match init 接着我们选择git作为存储容器. 然后创建一个空的git项目, 并将地址粘贴:12[14:11:57]: Please create a new, private git repository to store the certificates and profiles there[14:11:57]: URL of the Git Repo: https://github.com/yourname/your_match_files.git 此时, fastlane目录下会多出一个MatchFile, 这就代表你初始化成功了. 生成并证书及描述文件我们编辑fastlane/FastFile, 添加一个新的lane, 用来生成证书及描述文件, 并安装.12345lane :match_all do sh "bundle exec fastlane match development" sh "bundle exec fastlane match adhoc" sh "bundle exec fastlane match appstore"end 保存后 执行 fastlane match_all 这样会帮你生成所有环境的证书和描述文件, 同时存到你刚才配置的git地址中, 如果是第一次配置, 会让你配置下 git项目密码, 并且会将此密码存到本机的keychain中. 而之后在其他机器上使用时, 先创建一个新的lane: 12345lane :match_all_readonly do sh "fastlane match development --readonly" sh "fastlane match adhoc --readonly" sh "fastlane match appstore --readonly"end 然后在调用 fastlane match_all_readonly,在需要时 手动输入刚才配置的git仓库加密的密码即可, 之后每次打包便不需要手动操作了.不过也正因为match的问题, 使用ssh进行操作时, 都会卡在git加密密钥验证这个地方. 所以每次打包, 要不就是使用teamviewer来操作, 要不就是使用mini上的jenkins调用mini本地 fastlane 命令的方式来打包. AdHoc打包注意在使用gym前 请确认你的scheme已经勾选了Share 123456789101112131415lane :adhoc do # sh "pod install --no-repo-update" puts "开始打包 adhoc" gym( clean:true, scheme:"YourProjectTarget", configuration:"AdHoc", export_method:"ad-hoc", output_directory:"./build",# 打包后的 ipa 文件存放的目录 silent:true, ) # 使用fir上传 sh "fir p ../build/your.ipa -T YourFirToken" puts "打包完成"end 邮件通知 fastlane有一个邮件通知的action, 但是需要信用卡绑定才可以发送邮件, 于是我又找了一个替代品 – fastlane-plugin-send_e_mail 先添加plugin1fastlane add_plugin send_e_mail 然后在FastFile中添加一个新的lane:12345678910111213lane :send_mail do version = get_version_number(xcodeproj: "your_project.xcodeproj", target: "your_project_target") #build_number = get_build_number(xcodeproj: "your_project.xcodeproj") title = "your_app_name (iOS) #&#123;version&#125; 已提交AppStore审核." send_e_mail( stmp_server: 'smtp.exmail.qq.com', user_name: 'xxx@qqqiye.cn', password: 'xxxxxx', recipients: ['tom@qqqiye.cn','jeff@qqqiye.cn'], subject: title, message_body: "no reply" )end 然后直接在其他lane中调用这个send_mail就可:123456desc "Push a new release build to the App Store"lane :release do build_app(workspace: "VoiceOfGod.xcworkspace", scheme: "VoiceOfGod") upload_to_app_store send_mailend 关于Deliverfile的一些配置我的Deliverfile的配置是这样的 12345678910111213# The Deliverfile allows you to store various App Store Connect metadata# For more information, check out the docs# https://docs.fastlane.tools/actions/deliver/force true #强制不显示 preview网页.#build_number "30" #设置项目的build numberskip_screenshots true #跳过截图上传.phased_release true #分阶段分发submit_for_review false #提交完成直接进入review. 问题汇总increment_build_number报错或者无法使用Xcode-&gt;Build Settings -&gt; VERSIONING SYSTEM 设置成 Apple Generic. error: Provisioning profile “iOS Team Provisioning Profile: “ doesn’t include signing certificate “iPhone Developer: “Xcode-&gt;Build Settings -&gt; Code Signing Identity设置如下即可]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开发环境</tag>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于docker搭建项目管理平台redmine]]></title>
    <url>%2F2019%2F06%2F27%2F%E5%9F%BA%E4%BA%8Edocker%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0redmine%2F</url>
    <content type="text"><![CDATA[首发于 2018-07-14 15:23:01最后编辑于2019-06-27 22:42:03 前言最近在写一个开源的框架, 但是发现效率低下, 于是乎就寻觅了一遭提升开发效率的方法在前辈的提示下, 发现了一款名叫 redmine 的开源项目管理工具我粗略的看了下, 发现redmine不仅流程科学规范, 而且细致入微, 对鞭策自己开发及浏览开发进度是个非常不错的选择.正好我在公司有台用来垫显示器的闲置 Mac mini, 就利用一下好了. 搭建DockerDocker 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，降低了云计算应用开发的成本！使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！ 无论是应用开发者、运维人员、还是其他信息技术从业人员，都有必要认识和掌握 Docker，节约有限的生命。 考虑到以后更换设备的可能(比如说从这台Mac mini 更换到另一台垫显示器的Mac mini), 使用 Docker 来避免配置环境的重复劳动, 是最明智不过了. 安装DockerDocker-从入门到实践一书中已有非常详实准确的指南, 可以参看其中的安装步骤, 快速的安装Docker 安装完成后, Mac用户可能会报如下错误 1Docker does not rely on Virtualbox but may not work properly on systems with VirtualBox versions prior to v4.3.30 VirtualBox v4.3.28 is currently installed. Please upgrade or uninstall Virtualbox.Docker does not rely on Virtualbox but may not work properly on systems with VirtualBox versions prior to v4.3.30 VirtualBox v4.3.28 is currently installed. Please upgrade or uninstall Virtualbox. google了一下, 发现github中有关于这个的issue, 首先检查下本地环境的kextstat:输入命令1kextstat | grep -i virtualbox 此时如果有信息反馈, 那么执行下一步:12cd /Library/Application\ Support/VirtualBox/rm -rf *.kext 清除文件后, 再执行:1kextstat | grep -i virtualbox 这时 应该不会有任何信息出来, 接着我们在重启下mac, 然后再次运行Docker 就OK了. 安装RedmineRedmine依赖数据库, 我这里使用的是MySQL, 而docker hub中已经有redmine及MySQL的官方镜像了, 我们直接加载就行. 加载镜像12docker pull mysql:5.7.22docker pull redmine:4.0.4 安装成功之后，执行docker images，可以看到两个镜像的描述，类似如下：1234# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql 5.7.22 66bc0f66b7af 2 weeks ago 372MBredmine 4.0.4 a3175f2fb34e 2 months ago 574MB docker 启动 mysql1docker run -d -p 3306:3306 --name server-mysql -e MYSQL_ROOT_PASSWORD=&quot;pass&quot; -e MYSQL_DATABASE=redmine mysql:5.7.22 这里为物理机和虚拟机的3306端口做了端口映射，以让外部用户可以通过3306端口访问mysql实例, mysql关于默认不支持utf-8的处理我是一开始没有处理这个问题, 然后就立马绑定并run redmin了, 然而在使用redmine的时候有许多地方会报interal error的错误.查看了log发现都是mysql插入utf8字段的的错误. 所以推荐启动完mysql之后, 就要着手立马处理问题, 否则像我一样发现问题再改, 就要废很多功夫了. 解决流程1.查看 刚才创建的MYSQL的 container id1docker ps -a 2.进入1docker exec -it b63ce7258234 /bin/bash 3.切换成root账号, 密码就是刚才配置的(pass)1mysql -u root -p 4.查看MySQL字符集12SHOW VARIABLES LIKE &apos;character_set_%&apos;;SHOW VARIABLES LIKE &apos;collation_%&apos;; 得到输出:12345678910111213141516171819202122232425// 输出mysql&gt; SHOW VARIABLES LIKE &apos;character_set_%&apos;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | latin1 || character_set_connection | latin1 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | latin1 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.01 sec)mysql&gt; SHOW VARIABLES LIKE &apos;collation_%&apos;;+----------------------+-------------------+| Variable_name | Value |+----------------------+-------------------+| collation_connection | latin1_swedish_ci || collation_database | latin1_swedish_ci || collation_server | latin1_swedish_ci |+----------------------+-------------------+3 rows in set (0.00 sec) 5.设置外部访问的编码1SET NAMES &apos;utf8&apos;; 1234567891011121314151617181920212223242526272829// 输出mysql&gt; SET NAMES &apos;utf8&apos;;Query OK, 0 rows affected (0.00 sec)// 再次查看MySQL字符集, 发现已经变化.mysql&gt; SHOW VARIABLES LIKE &apos;character_set_%&apos;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec)mysql&gt; SHOW VARIABLES LIKE &apos;collation_%&apos;;+----------------------+-------------------+| Variable_name | Value |+----------------------+-------------------+| collation_connection | utf8_general_ci || collation_database | latin1_swedish_ci || collation_server | latin1_swedish_ci |+----------------------+-------------------+3 rows in set (0.01 sec) 6.修改mysql配置文件 (/etc/mysql/mysql.conf.d/mysqld.cn) 12// 先退出exit 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 编辑配置文件// 由于此环境内没有vim 所以直接用 echo &quot;下面文本的内容&quot; &gt; /etc/mysql/mysql.conf.d/mysqld.cn 进行覆盖# Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.## This program is free software; you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation; version 2 of the License.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this program; if not, write to the Free Software# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA## The MySQL Server configuration file.## For explanations see# http://dev.mysql.com/doc/mysql/en/server-system-variables.html[mysql]default-character-set = utf8[mysql_safe]default-character-set = utf8[client]default-character-set = utf8[mysqld]pid-file = /var/run/mysqld/mysqld.pidsocket = /var/run/mysqld/mysqld.sockdatadir = /var/lib/mysql#log-error = /var/log/mysql/error.log# By default we only accept connections from localhost#bind-address = 127.0.0.1# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0init_connect = &apos;SET NAMES utf8&apos;character-set-server = utf8collation-server = utf8_unicode_ci 7.退出, 停止容器123exitdocker stop b63ce7258234 8.基于刚才的容器创建一个新的镜像1docker commit b63ce7258234 mysql-utf8:5.7.22 12// 删除刚才使用的容器docker rm b63ce7258234 9.基于刚才创建的镜像，启动一个新的容器1docker run -d -p 3306:3306 --name server-mysql-uft8 -e MYSQL_ROOT_PASSWORD=&quot;pass&quot; -e MYSQL_DATABASE=redmine mysql-utf8:5.7.22 好了，修改就到此结束了，后面创建mysql容器时只要使用这个镜像就无需再重新修改字符集了 docker启动redmine1docker run -d -p 3000:3000 --name=server-redmine -e MYSQL_ROOT_PASSWORD=&quot;pass&quot; --link server-mysql-uft8:mysql redmine:4.0.4 这里为物理机和虚拟机的3000与3000端口做了端口映射，使用外部用户可以通过8080端口访问redmine. 一切正常的话, 使用 docker ps -a 可以看到docker中运行的进程:1234# docker ps -aONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc7a2a67fb328 redmine:4.0.4 &quot;/docker-entrypoint.…&quot; 14 minutes ago Up 18 minutes 0.0.0.0:3000-&gt;3000/tcp server-redminec548ae6a6002 mysql-utf8:5.7.22 &quot;docker-entrypoint.s…&quot; 15 minutes ago Up 18 minutes 0.0.0.0:3306-&gt;3306/tcp mysql-utf8 注意使用最新的mysql会出错, 因为 mysql:latest (mysql 8)中修改了authentication method 导致redmine(redmine目前19-06-27最高支持的mysql版本是5.7.26)无法登录. 在第一次进入redmine的管理页面时, 会提示加载默认配置, 注意将语言勾选为English 以避免中文默认配置无法新建问题的Bug… 完成浏览器中打开 localhost:3000 就可以访问redmine开始玩耍了.]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS 越狱后如何更改默认的shell为zsh]]></title>
    <url>%2F2019%2F06%2F14%2FiOS-%E8%B6%8A%E7%8B%B1%E5%90%8E%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84shell%2F</url>
    <content type="text"><![CDATA[通过ssh登录手机之后, 按照以下步骤操作 12345678// 安装curl$ apt-get upgrade curl// 安装awk$ apt-get install gawk// 安装on-my-zsh$ sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 安装完成后会提示无法使用chsh切换默认shell, 需要手动操作.然而使用chsh是无论如何都切换不了的. 于是便想着通过修改 /etc/passwd文件中的设置来更改, 但是并没有起作用. google了一圈也未果, 最终在/etc目录下发现了master.passwd这个文件, 于是修改关于root的配置. 将最后bin/sh改为bin/zsh即可.]]></content>
  </entry>
  <entry>
    <title><![CDATA[组织代码中的依赖关系]]></title>
    <url>%2F2019%2F05%2F22%2F%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[什么是依赖关系例子:123456789101112/// Swift democlass Canvas &#123; var color: UIColor func drawCircle(at origin: (Double, Double), d: Double) &#123; let pen = Pencil(of: color) pen.circle(at: origin, d: d) &#125;&#125;let canvas = Canvas(color: .red)canvas.drawCircle(at: (0, 0), d: 10) 首先，是由于对类型名称的了解而引入的依赖关系。这里Canvas要求必须存在一个叫做Pencil的 其次，是由于要发送给其它对象的方法名而引入的依赖关系。这里Canvas要求Pencil中必须有一个叫做circle的方法 第三，是方法的参数引入的依赖关系。既然Canvas创建了Pencil对象，它自然就需要知道Pencil的init方法需要接受一个UIColor对象除了上面三点之外，还有一类依赖关系是参数的顺序。但由于Swift并不像Ruby一样可以通过命名参数调整顺序，因此这类依赖关系，我们就不在这里讨论了 评估项目中类依赖关系的方法 了解了一些具体的处理依赖关系的方法之后，这一节最后，我们介绍一个评估依赖关系的方法。只有找到项目中最危险的分子，才能最安全有效的实施重构。对于一个类型来说，我们可以从两个方面来评估它： 在未来发生修改的可能性； 类型的依赖关系的多少；而这两个方面，又不是彼此独立的，我们可以画一个平面图来表达它们的关系： 这里，越靠近顶部的类型，包含的依赖关系越多；越靠近右侧的类型，越可能发生修改。重构之前，我们要做的第一件事，就是把收集到的类型，对号入座地收集到这个图里。 通常，可以放在区域A中的类型，抽象级别应该是最高的，它们通常是一些接口或者抽象基类这样的东西，只用于约定行为。因此，它们非常稳定，几乎不会改变。对于这样的类型，即便它们有很多依赖关系（例如：Swift中的Collection就是多个protocols组合起来的），也是没问题的。 而对于B和C区域的类型，通常它们都不是我们要关注的重点。项目中，绝大多数的类型，应该属于这两个区域。由于它们的依赖关系并不多，所以你会发现对这些类型的修改，你的脑子里一下子就能反映出具体的方案并确定结果。当然，也正因为如此，其实重构它们的收益，并不大 :) 最后，就是区域D中的类型。它们才是项目中最危险的分子。它们不仅依赖关系多，还经常需要被需改。所谓的Massive View Controller就是最典型的例子之一。尽管修改它们并不容易，但你要知道，这些类型，绝对是你在开始重构的时候，一定要要优先考虑的对象。 解决方法从名字依赖到方法依赖1234567891011121314151617181920212223/// Swift demoprotocol Pen &#123; func circle(at origin: (Double, Double), d: Double)&#125;class Pencil: Pen &#123; func circle(at origin: (Double, Double), d: Double) &#123;&#125;&#125;class Canvas &#123; func drawCircle( at origin: (Double, Double), d: Double, by pen: Pen) &#123; pen.circle(at: origin, d: d) &#125;&#125;let canvas = Canvas()canvas.drawCircle( at: (0, 0), d: 10, by: Pencil(of: .red)) 而这种直接把对象当作参数传递的行为，就叫做依赖注入（Dependency Injection）。把原本Canvas依赖的Pencil对象，“注入”到drawCircle。没错，这个听起来很复杂的名称，实际上就这么简单的一回事儿。 不过在很多时候，这种方法仍旧是不可行的。例如，项目工期不允许我们立即修改某个接口的签名，或者，我们根本就无法修改来自第三方的代码。但即便是面对这些情况，我们仍旧可以通过依赖注入在某些程度上缓解对象之间的依赖关系，以便于在时机成熟的时候，更方便的处理问题。 把对象的创建统一隔离到init方法如果条件不允许立即修改drawCircle的签名，至少，我们也要把Pencil对象的创建从drawCircle的定义里搬出来，放到Canvas的init方法里：123456789101112/// SWIFTclass Canvas &#123; var pen: Pencil init(pen: Pencil) &#123; self.pen = pen &#125; func drawCircle(at origin: (Double, Double), d: Double) &#123; pen.circle(at: origin, d: diameter) &#125;&#125;let canvas = Canvas(pen: Pencil(of: .red))canvas.drawCircle(at: (0, 0), d: 10) 这样做有两个目的： 一个是让drawCircle不再隐性的使用一个具象的Pencil对象，未来我们修改drawCircle签名的时候，可以不用再修改它的实现； 另一个则是更明确的把Canvas依赖Pencil这个事实暴露出来，从上面的例子就可以看到，每次创建Canvas的时候，都“注入”了一个Pencil对象，这就好比在时刻提醒你：喔，对了，Canvas现在可是得依赖Pencil的。在条件允许的时候，我得把它修改过来； 尽可能在复杂方法中剥离依赖关系除了把依赖的对象暴露在init方法之外，另外一个无副作用的改进，就是把“深埋”在复杂方法里的依赖关系从中剥离开，变成一个属于类自身的方法或属性，例如：123456789101112131415/// SWIFTclass Canvas &#123; var pen: Pencil init(pen: Pencil) &#123; self.pen = pen &#125; func drawCircle(at origin: (Double, Double), d: Double) &#123; /// Complicated render before draw circle(at: origin, d: diameter) /// Complicated pipeline work &#125; func circle(at origin: (Double, Double), d: Double) &#123; pen.circle(at: origin, d: diameter) &#125;&#125; 这样做的目的，和我们在init中注入对象是类似的，也就是尽可能明确在未来重构代码时，需要修改的代码边界。让需要重构的部分，明确暴露出来。 多层容器也就是说，BoxueUserSessionRepository是有状态的，我们不能够随意创建BoxueUserSessionRepository对象，如果有多个地方需要这个对象，我们应该让它成为一个单例。而这，也是我们通过容器类创建对象的一个重要作用：即创建并持有需要长时间保持的依赖关系。 但如果我们在一个项目中只使用一个容器类，往往还是会有一些不方便的地方。 最直接的问题，就是这个类的体积会越来越大，它会包含越来越多的单例对象和工厂方法。最终，自己演化成一个Massive Container，变得难以维护。 另一个问题是，一个App中的依赖关系往往不是平等的。有些依赖关系存活在App的整个生命周期、有些依赖关系只在用户登录后才产生，有些关系，则仅和某个UI、某个交互相关。如果把这些依赖关系的管理都放在一个容器中，我们可能就需要不断在这个容器中安插Optional类型的属性，然后通过unwrap它来判断各种情况。显然，这会让我们的container变得更加复杂。 面对这种问题，我们就可以使用多层容器来解决。 多层容器分层规则按照一个对象从创建到销毁所覆盖到的区域的大小，我们可以把这个区域分成4大类： App作用域，这个作用域里是我们最熟悉的单例对象，它们从App启动的时候就被创建，之后便一直保持在内存里，直到App结束。我们之前定义的sharedMainViewModel就属于这类作用域； 用户作用域，是指在用户登录后创建，登出后销毁的对象； 功能作用域，是指用户使用了某个功能之后才创建，离开这个功能后就可以销毁的对象。一会儿，我们就会看到这样一个例子； 交互作用域，是指只有在执行了某个交互动作（例如手势）之后才创建的对象，这应该是生命周期最短的一类对象了； 有了这些作用域，我们就可以制定一个简单的对容器进行分层的规则： 首先，管理App作用域的容器永远都是根容器，我们上一节定义的BoxueAppDepedencyContainer就是如此； 其次，每当我们需要一个新的对象作用域时，就创建一个新的子容器来管理其中所有对象的创建方法； 最后，下层容器可以向上层容器请求其管理的依赖关系； 例子:BoxueGuideDependencyContainer要可以向它的上层容器BoxueAppDepedencyContainer请求数据，这可以通过在init方法中注入上层容器实现：123456789101112public class BoxueGuideDependencyContainer &#123; /// - Properties let sharedMainViewModel: MainViewModel let sharedUserSessionRepository: UserSessionRepository init(appDependencyContainer: BoxueAppDepedencyContainer) &#123; self.sharedMainViewModel = appDependencyContainer.sharedMainViewModel self.sharedUserSessionRepository = appDependencyContainer.sharedUserSessionRepository &#125;&#125; 其他如何组织文件在项目目录中，这种“一个protocol会对应多个实现”的情况，我们都用下面的方式来组织文件： 在图中可以看到，Auth和UserSessionStore分别表示要实现的功能。在根目录中，我们定义对应的protocol。然后在Implementations中，包含对这个protocol的多个实现。 MVVM 通常，我们会对“究竟应该把网络IO的代码放到哪里”这样的问题感到困惑。实际上，严格来说，网络IO只是View Model获取数据的一种途径而已，从这个角度上说，它和本地读取数据没有很大区别。因此我们也不应该有类似这样的困惑。只不过，当View Model中存在着多种获取数据的通路的时候，我们会在View Model和Model之间加一层代理来屏蔽掉这个差别。我们管这层代理，就叫做Repository。 因此，View Model和Model之间的交互，就可以进一步被细化成这样： 所谓的view model status，就是一组表示当前view类型的case12345678public enum GuideViewStatus &#123; case welcome case signIn case signUp case contactUs case resetPassword case requestNotification&#125;]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>架构</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter-go代码开发规范]]></title>
    <url>%2F2019%2F05%2F10%2Fflutter-go%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Flutter Go 代码开发规范 0.1.0 版转发自alibab flutter-go仓库 代码风格标识符三种类型大驼峰类、枚举、typedef和类型参数 12345class SliderMenu &#123; ... &#125;class HttpRequest &#123; ... &#125;typedef Predicate = bool Function&lt;T&gt;(T value); 包括用于元数据注释的类 123456789class Foo &#123; const Foo([arg]);&#125;@Foo(anArg)class A &#123; ... &#125;@Foo()class B &#123; ... &#125; 使用小写加下划线来命名库和源文件1234library peg_parser.source_scanner;import 'file_system.dart';import 'slider_menu.dart'; 不推荐如下写法： 1234library pegparser.SourceScanner;import 'file-system.dart';import 'SliderMenu.dart'; 使用小写加下划线来命名导入前缀1234import 'dart:math' as math;import 'package:angular_components/angular_components' as angular_components;import 'package:js/js.dart' as js; 不推荐如下写法： 1234import 'dart:math' as Math;import 'package:angular_components/angular_components' as angularComponents;import 'package:js/js.dart' as JS; 使用小驼峰法命名其他标识符1234567var item;HttpRequest httpRequest;void align(bool clearItems) &#123; // ...&#125; 优先使用小驼峰法作为常量命名1234567const pi = 3.14;const defaultTimeout = 1000;final urlScheme = RegExp('^([a-z]+):');class Dice &#123; static final numberGenerator = Random();&#125; 不推荐如下写法： 1234567const PI = 3.14;const DefaultTimeout = 1000;final URL_SCHEME = RegExp('^([a-z]+):');class Dice &#123; static final NUMBER_GENERATOR = Random();&#125; 不使用前缀字母因为Dart可以告诉您声明的类型、范围、可变性和其他属性，所以没有理由将这些属性编码为标识符名称。 1defaultTimeout 不推荐如下写法： 1kDefaultTimeout 排序为了使你的文件前言保持整洁，我们有规定的命令，指示应该出现在其中。每个“部分”应该用空行分隔。 在其他引入之前引入所需的dart库12345import 'dart:async';import 'dart:html';import 'package:bar/bar.dart';import 'package:foo/foo.dart'; 在相对引入之前先引入在包中的库1234import 'package:bar/bar.dart';import 'package:foo/foo.dart';import 'util.dart'; 第三方包的导入先于其他包1234import 'package:bar/bar.dart';import 'package:foo/foo.dart';import 'package:my_package/util.dart'; 在所有导入之后，在单独的部分中指定导出1234import 'src/error.dart';import 'src/foo_bar.dart';export 'src/error.dart'; 不推荐如下写法： 123import 'src/error.dart';export 'src/error.dart';import 'src/foo_bar.dart'; 所有流控制结构，请使用大括号这样做可以避免悬浮的else问题 12345if (isWeekDay) &#123; print('Bike to work!');&#125; else &#123; print('Go dancing or read a book!');&#125; 例外一个if语句没有else子句，其中整个if语句和then主体都适合一行。在这种情况下，如果你喜欢的话，你可以去掉大括号 1if (arg == null) return defaultValue; 如果流程体超出了一行需要分划请使用大括号： 123if (overflowChars != other.overflowChars) &#123; return overflowChars &lt; other.overflowChars;&#125; 不推荐如下写法： 12if (overflowChars != other.overflowChars) return overflowChars &lt; other.overflowChars; 注释要像句子一样格式化除非是区分大小写的标识符，否则第一个单词要大写。以句号结尾(或“!”或“?”)。对于所有的注释都是如此：doc注释、内联内容，甚至TODOs。即使是一个句子片段。 1234greet(name) &#123; // Assume we have a valid name. print('Hi, $name!');&#125; 不推荐如下写法： 1234greet(name) &#123; /* Assume we have a valid name. */ print('Hi, $name!');&#125; 可以使用块注释(/…/)临时注释掉一段代码，但是所有其他注释都应该使用// Doc注释使用///文档注释来记录成员和类型。 使用doc注释而不是常规注释，可以让dartdoc找到并生成文档。 12/// The number of characters in this chunk when unsplit.int get length =&gt; ... 由于历史原因，达特茅斯学院支持道格评论的两种语法:///(“C#风格”)和/…* /(“JavaDoc风格”)。我们更喜欢/// 因为它更紧凑。/和/在多行文档注释中添加两个无内容的行。在某些情况下，///语法也更容易阅读，例如文档注释包含使用标记列表项的项目符号列表。 考虑为私有api编写文档注释Doc注释并不仅仅针对库的公共API的外部使用者。它们还有助于理解从库的其他部分调用的私有成员 用一句话总结开始doc注释以简短的、以用户为中心的描述开始你的文档注释，以句号结尾。 1234/// Deletes the file at [path] from the file system.void delete(String path) &#123; ...&#125; 不推荐如下写法： 1234567/// Depending on the state of the file system and the user's permissions,/// certain operations may or may not be possible. If there is no file at/// [path] or it can't be accessed, this function throws either [IOError]/// or [PermissionError], respectively. Otherwise, this deletes the file.void delete(String path) &#123; ...&#125; “doc注释”的第一句话分隔成自己的段落在第一个句子之后添加一个空行，把它分成自己的段落 1234567/// Deletes the file at [path].////// Throws an [IOError] if the file could not be found. Throws a/// [PermissionError] if the file is present but could not be deleted.void delete(String path) &#123; ...&#125; Flutter_Go 使用参考库的引用flutter go 中，导入lib下文件库，统一指定包名，避免过多的12```dartpackage:flutter_go/ 字符串的使用使用相邻字符串连接字符串文字如果有两个字符串字面值(不是值，而是实际引用的字面值)，则不需要使用+连接它们。就像在C和c++中，简单地把它们放在一起就能做到。这是创建一个长字符串很好的方法但是不适用于单独一行。 123raiseAlarm( 'ERROR: Parts of the spaceship are on fire. Other ' 'parts are overrun by martians. Unclear which are which.'); 不推荐如下写法: 12raiseAlarm('ERROR: Parts of the spaceship are on fire. Other ' + 'parts are overrun by martians. Unclear which are which.'); 优先使用模板字符串1'Hello, $name! You are $&#123;year - birth&#125; years old.'; 在不需要的时候，避免使用花括号12'Hi, $name!'"Wear your wildest $decade's outfit." 不推荐如下写法： 1'Hello, ' + name + '! You are ' + (year - birth).toString() + ' y...'; 不推荐如下写法： 12'Hi, $&#123;name&#125;!'"Wear your wildest $&#123;decade&#125;'s outfit." 集合尽可能使用集合字面量如果要创建一个不可增长的列表，或者其他一些自定义集合类型，那么无论如何，都要使用构造函数。 123var points = [];var addresses = &#123;&#125;;var lines = &lt;Lines&gt;[]; 不推荐如下写法： 12var points = List();var addresses = Map(); 不要使用.length查看集合是否为空12if (lunchBox.isEmpty) return 'so hungry...';if (words.isNotEmpty) return words.join(' '); 不推荐如下写法： 12if (lunchBox.length == 0) return 'so hungry...';if (!words.isEmpty) return words.join(' '); 考虑使用高阶方法转换序列如果有一个集合，并且希望从中生成一个新的修改后的集合，那么使用.map()、.where()和Iterable上的其他方便的方法通常更短，也更具有声明性 123var aquaticNames = animals .where((animal) =&gt; animal.isAquatic) .map((animal) =&gt; animal.name); 避免使用带有函数字面量的Iterable.forEach()在Dart中，如果你想遍历一个序列，惯用的方法是使用循环。 123for (var person in people) &#123; ...&#125; 不推荐如下写法： 123people.forEach((person) &#123; ...&#125;); 不要使用List.from()，除非打算更改结果的类型给定一个迭代，有两种明显的方法可以生成包含相同元素的新列表 12var copy1 = iterable.toList();var copy2 = List.from(iterable); 明显的区别是第一个比较短。重要的区别是第一个保留了原始对象的类型参数 12345// Creates a List&lt;int&gt;:var iterable = [1, 2, 3];// Prints "List&lt;int&gt;":print(iterable.toList().runtimeType); 12345// Creates a List&lt;int&gt;:var iterable = [1, 2, 3];// Prints "List&lt;dynamic&gt;":print(List.from(iterable).runtimeType); 参数的使用使用=将命名参数与其默认值分割开由于遗留原因，Dart均允许“:”和“=”作为指定参数的默认值分隔符。为了与可选的位置参数保持一致，使用“=”。 1void insert(Object item, &#123;int at = 0&#125;) &#123; ... &#125; 不推荐如下写法： 1void insert(Object item, &#123;int at: 0&#125;) &#123; ... &#125; 不要使用显式默认值null如果参数是可选的，但没有给它一个默认值，则语言隐式地使用null作为默认值，因此不需要编写它 123void error([String message]) &#123; stderr.write(message ?? '\n');&#125; 不推荐如下写法: 123void error([String message = null]) &#123; stderr.write(message ?? '\n');&#125; 变量不要显式地将变量初始化为空在Dart中，未显式初始化的变量或字段自动被初始化为null。不要多余赋值null 123456789101112int _nextId;class LazyId &#123; int _id; int get id &#123; if (_nextId == null) _nextId = 0; if (_id == null) _id = _nextId++; return _id; &#125;&#125; 不推荐如下写法： 123456789101112int _nextId = null;class LazyId &#123; int _id = null; int get id &#123; if (_nextId == null) _nextId = 0; if (_id == null) _id = _nextId++; return _id; &#125;&#125; 避免储存你能计算的东西在设计类时，您通常希望将多个视图公开到相同的底层状态。通常你会看到在构造函数中计算所有视图的代码，然后存储它们: 应该避免的写法： 12345678910class Circle &#123; num radius; num area; num circumference; Circle(num radius) : radius = radius, area = pi * radius * radius, circumference = pi * 2.0 * radius;&#125; 如上代码问题： 浪费内存 缓存的问题是无效——如何知道何时缓存过期需要重新计算？ 推荐的写法如下： 12345678class Circle &#123; num radius; Circle(this.radius); num get area =&gt; pi * radius * radius; num get circumference =&gt; pi * 2.0 * radius;&#125; 类成员不要把不必要地将字段包装在getter和setter中不推荐如下写法： 1234567class Box &#123; var _contents; get contents =&gt; _contents; set contents(value) &#123; _contents = value; &#125;&#125; 优先使用final字段来创建只读属性尤其对于 StatelessWidget 在不需要的时候不要用this不推荐如下写法： 1234567891011class Box &#123; var value; void clear() &#123; this.update(null); &#125; void update(value) &#123; this.value = value; &#125;&#125; 推荐如下写法： 1234567891011class Box &#123; var value; void clear() &#123; update(null); &#125; void update(value) &#123; this.value = value; &#125;&#125; 构造函数尽可能使用初始化的形式不推荐如下写法： 1234567class Point &#123; num x, y; Point(num x, num y) &#123; this.x = x; this.y = y; &#125;&#125; 推荐如下写法： 1234class Point &#123; num x, y; Point(this.x, this.y);&#125; 不要使用newDart2使new 关键字可选 推荐写法： 12345678910Widget build(BuildContext context) &#123; return Row( children: [ RaisedButton( child: Text('Increment'), ), Text('Click!'), ], );&#125; 不推荐如下写法： 12345678910Widget build(BuildContext context) &#123; return new Row( children: [ new RaisedButton( child: new Text('Increment'), ), new Text('Click!'), ], );&#125; 异步优先使用async/await代替原始的futuresasync/await语法提高了可读性，允许你在异步代码中使用所有Dart控制流结构。 123456789101112Future&lt;int&gt; countActivePlayers(String teamName) async &#123; try &#123; var team = await downloadTeam(teamName); if (team == null) return 0; var players = await team.roster; return players.where((player) =&gt; player.isActive).length; &#125; catch (e) &#123; log.error(e); return 0; &#125;&#125; 当异步没有任何用处时，不要使用它如果可以在不改变函数行为的情况下省略异步，那么就这样做。、 123Future afterTwoThings(Future first, Future second) &#123; return Future.wait([first, second]);&#125; 不推荐写法： 123Future afterTwoThings(Future first, Future second) async &#123; return Future.wait([first, second]);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ARTS_Week_4.md]]></title>
    <url>%2F2019%2F05%2F10%2FARTS-Week-4%2F</url>
    <content type="text"><![CDATA[AlgorithmThe Clean Code Blog 在过去几年中, 我们已经看到了关于系统架构方面的一系列想法. 它们包括: Hexagonal Architecture (俗称Ports and Adapters) by Alistair Cockburn and adopted by Steve Freeman, and Nat Pryce in their wonderful book Growing Object Oriented Software Onion Architecture by Jeffrey Palermo Screaming Architecture from a blog of mine last year DCI from James Coplien, and Trygve Reenskaug. BCE by Ivar Jacobson from his book Object Oriented Software Engineering: A Use-Case Driven Approach 虽然这些架构在一些细节中有很多不同, 但是它们还是非常相似的.它们都有同一个目标–对于关注点的分离. 它们都通过将软件分层来实现分离. 每一个都至少有一个层级用于业务规则, 另一个则关于接口.每一个架构都满足: 独立于任何框架. 该架构不应该依赖于任何已经存在的功能丰富的软件的一些库. 这将允许你把框架当做工具来使用, 而不用强制的将自己的系统塞进有限的约束中. 测试友好. 业务规则可以在脱离UI、数据库、网页服务或者任何其他外部元素的情况下进行测试. 独立于UI. UI的改变可以很容易, 而不用改变除系统中UI之外的剩余东西. 例如, 一个网页UI可以在不改变业务规则的情况下被一个控制台UI所代替. 独立于数据库. 你可以用Oracle活着SQLServer来替换Mongo, BigTable, CouchDB或者其他的. 你的业务规则没有与数据库绑定. 独立于任何外部机构. 实际上就是让你的业务规则简单的不知道任何除自己之外的东西. 本文顶部的图片是尝试将所以这些架构继承到一个可操作的想法中. 依赖规则图片中的同心圆代表着软件的不同区域. 通常来讲, 离中心点越远, 软件的层级就越高. 外圈是机制, 内圈是政策.使这个架构生效的首页规则就是依赖规则. 这个规则阐明了源代码的依赖只能由外圈指向内圈. 内圈并不能知道外圈的任何事情. 尤其要是注意的是, 声明在外圈的某物不可以在内圈中提及. 这包括函数, 类, 变量或者其他软件中的被命名的实体. 实体层实体封装了企业间的业务规则. 一个实体可以是一个有方法的对象, 一个数据结构体的集合或者是函数. 只要实体可以被企业中的血多不同应用程序使用, 其他的都无关紧要.如果你没有企业, 并且你仅仅只写了一个简单的app, 那么这些实体指的就是你app中的业务对象. 他们封装了最通用最高级的规则. 当外部规则改变时, 它们是最不可能发生改变的. 例如, 你不会期望这些对象们随着页面导航或者安全性的改变而改变. 任何特定的应用程序操作更改都不应该影响到实体层. 用例层软件中的这一层包括了app特定的业务规则. 它封装并且实现了系统中的所有用例. 这些用例协调了从实体层来的数据流, 并且只是这些实体用它们的企业级业务规则来实现用例的目标.我们不希望改变这一层, 导致影响其他层. 我们也不期望这一层会被任何其他外部的改变, 如数据库, UI, 或者其他人么通用框架所影响. 这一层是独立的. 然而我们确实希望改变程序的操作会影响用例从而影响软件中的这一层. 如果用例的细节发生改变, 那么这一层肯定会被影响. 接口适配层软件中的这一层是一个将用例或者实体的从一个最方便格式的数据转换成一个适用于如数据库或者网页的外部机构的最简便格式的适配器的集合. 例如, 这一层将会完整的包含GUI中MVC的架构. Presenters, Views, and Controllers就是属于这的. 由可能仅仅是某种数据结构的模型通过Controllers传递到用例层, 然后再通过用力层回调给Presents和Views.相似的, 数据也是在这层从一个最简便的形式的实体或用例被转换成了一个适用于任何持久性框架(如数据库)的最简便的格式. 此层中的任何代码都不应知道关于数据库的任何事情. 如果数据库是SQL 数据库, 那么所有的SQL操作都应该在这层被限制, 更不能直接操作数据库.此层中还包括将外层数据格式(如外部服务)转换成用例和实体使用的内层格式的任何其他适配器. 框架和驱动最外层通常由框架和工具组成，例如数据库，Web框架等。通常，除了与下一层内部通信的粘合代码之外，您不会在此层中编写太多代码.这层是所有的细节实现所在. 网络是细节, 数据库是鞋机. 我们将这些东西放在最外层, 以确保变动他们的时候造成的伤害最小. 只有4层?并非如此, 这些层只是一些概要. 你可以发现你所需要的会超过这四层. 这也没有规定必须只有四层. 然而, 依赖规则 总是适用. 源代码依赖总是自外向内. 最外层是最低等级的具体细节实现. 随着你向内移动，软件变得更加抽象，并封装了更高级别的策略. 最内层是最抽象通用的. 跨越边界图的右下方是我们如何跨越层级边界的实例. 它展示了在下一层中Controllers和Presenters通过Use Cases是如何交流的. 注意这个控制流. 它开始于controller中,然后穿过use case,再然后在presenter的executing中结束.同时也注意源代码的依赖. 它们中的每一个都指向了Use Cases层.我们通常通过使用依赖倒置原则来解决这些明显的矛盾. 在一些语音中, 如Java语言, 我们可以安排好接口和继承关系, 使得源代码依赖性反对跨越边界的正确点处的控制流. 例如, 思考这种情况, 用例需要调用presenter.然而, 这个回调肯定不能被分发因为这违反了依赖规则.例如, 许多数据库框架在一次查询中会返回包含一个便捷数据格式的响应. 我们称之为RowStructure. 我们并非是想向内传递一个row structure. 这将违反了依赖规则, 因为它将强制内层得知外层的某些事情.所以我们会传递一个数据来跨越边界, 我们会使用对内层来讲最方便的形式. 结论遵守这些简单的规则并不难, 而且这将会省去很多令你头疼的问题. 通过将软件分成多个层，并符合依赖规则，您将创建一个本质上可测试，并具有潜在的所有好处的系统. 当系统挖外部的一部分变得过时时(如数据库, 网络框架), 你可以最小粒度的替换它们. TipsShare]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS Week 3]]></title>
    <url>%2F2019%2F04%2F08%2FARTS-Week-3%2F</url>
    <content type="text"><![CDATA[Algorithm: NO.237 Delete Node in a Linked ListWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list – head = [4,5,1,9], which looks like following: Example 1:123Input: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function. Example 2:123Input: head = [4,5,1,9], node = 1Output: [4,5,9]Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function. Note: The linked list will have at least two elements. All of the nodes’ values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. 解答:这道题比较巧妙的地方就在于函数只被传入一个参数, 且传入的就是要被删除的node, 所以需要转化下思路. 1234567891011121314/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125; Review Getting Started with Auto-renewable Subscriptions in iOS自动续订订阅是iOS IAP体系内的一个分支, 它允许app在一定时间内提供内容或功能并对其收费. 这种类型的内购产品类型将超越IAP中的对于消耗品和非消耗品的一次性消费和低频消费的购买模式所产生的经济效益, 并以此来扩展app的潜在收益. 通过之前为自己的多个app实现过几次, 我们注意到他们无法满足你对苹果的期望, 在基于订阅体系的app模式, 他们无法提供足够完成和有效的解决方案. 使用自动续订订阅的标准使用自动续订订阅的app可以在规定时间内(例如,每月,每年等等)收取长期费用. 自动续订订阅与IAP体系中其他不能提供带有时间性质的产品所不同. 它们提供了额外的好处, 即无需进一步干预即可为用户收取订阅费用. Apple将其不同类型的应用内购买成为”产品”. 有关其应用内购买产品(消耗性, 非消耗性和自动续订订阅)之间的基本差异, 请考虑这些示例. 一个消耗性的的产品,可能是游戏app中一个小时的经验提升的增益效果. 另一方面, 一个非消耗性产品可以是采取解锁主题的形式展示, 因为它可能在以后再次恢复.从历史角度来看, 如果报刊应用程序和出版物只是下发基础性的内容而不是提供额外的功能的访问, 那么苹果会限制这类产品使用自动续订订阅系统. 这在iTunes Connect中的自动续订订阅的设置(例如需要提供一个”publication”名称)过程中仍然很明显. 这些年来, Apple放宽了这一限制, 并允许非报停应用程序加入自动续订订阅的潮流. 自动续订订阅现在更多的是用于生产力和业务应用的程序中. 例如, 在任务管理app Omnifocus中, 如果用户已经超期了14天的免费使用, 那么便会向用户收取双层订阅费用. 甚至像一款 脑力开发的app Lumosity, 提供一个免费的基本会员资格, 并使用自动续订订阅来解锁高级功能. 这个app同时也提供独立或者朋友和家庭订阅计划. 创建一个自动续订订阅创建自动续订订阅的第一步与创建其他IAP产品并没有多少不同. 你会遇到的主要的不同就是你需要配置商品的自动续订周期时间(如 按月, 按年 等)和提供免费试用. 与此同时, 免费试用是回被限制在很少几个的时间段里, 并且它并不是动态的. 如果你想要要求超出选项提供的免费周期时间或者你想要提供不同的试用等级, 那么非常推荐你忽略这些选项并且手动处理. 当用户同意提供他们的详细信息(名字, 邮箱, 地址)时, 开发者也可以提供免费试用时间. Tips如果在UIScrollview中使用Autolayout对其子控件进行布局时, 需要注意以下两点: ScrollView内部子控件的尺寸不能以scrollView的尺寸为参照 ScrollView内部的子控件的约束必须完整 首先,子控件的尺寸不能以ScrollView的尺寸为参照,那么我们有两种选择:12提供一个具体值的约束(比如200)子控件的尺寸可以参照ScrollView以外其它的控件的尺寸(如控制器的view的尺寸) 其次,约束”完整”的意思是说:子控件在水平及竖直方向上的约束要把ScrollView”撑满”. 也就是说,在水平方向上,我们需要设置:123子控件左侧与父控件的距离子控件自身的宽度子控件右侧距父控件的距离. 竖直方向上也一样,要设置:123子控件顶部距父控件的距离子控件的高度子控件底部距父控件的距离. Share分享一篇关于IAP自动续订订阅的定价策略的决策 WWDC 2018：IAP最佳實踐並增強活動營銷功能]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS Week 2]]></title>
    <url>%2F2019%2F04%2F01%2FARTS-Week-2%2F</url>
    <content type="text"><![CDATA[AlgorithmNo.3 Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Example 1:123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2:123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3:1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 解答:12345678910111213141516171819class Solution &#123; func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123; var map = [Character: Int](), i = 0, j = 0, longest = 0 let sChars = Array(s) while j &lt; sChars.count &#123; let c = sChars[j] if let index = map[c] &#123; // 1.滑动窗口 i = max(i, index) &#125; // 2. longest = max(longest, j - i + 1) j += 1 // 在j+=1之后在存到map中, 以及在2.处计算的 + 1, 是为了兼容 string长度为1的字符串 map[c] = j &#125; return longest &#125;&#125; 小记:为什么在上面代码中 1 处要使用max运算选出最大值, 而不是直接将index赋值给i?答: 直接将index赋值给i会导致处理类似abba这种情况出错. ReviewSwift Playgrounds in Depth(Part Two)原文: https://www.raywenderlich.com/4345-swift-playgrounds-in-depth 第二部分主要是讲Playground在项目中的应用. AttributedStrings.xcworkspace在项目中 直接添加一个playground文件(在Xcode10.1中,选中目录Command+N 新建文件 往下拉就可以找到新建Playground一栏)即可.添加完就可以直接引用所有包含的框架, 也可以进行进一步的测试. 12345678910111213141516171819202122232425import UIKitimport BonMotimport TextAttributesfunc attributedStringWithBonMot(_ inputString: String) -&gt; NSAttributedString &#123; let style = StringStyle( .color(.blue), .font(UIFont(name: "AmericanTypewriter", size: 24)!) ) return inputString.styled(with: style)&#125;attributedStringWithBonMot("Hellow BonMot")func attributedStringWithTextAttributes(_ inputString: String) -&gt; NSAttributedString &#123; let attributes = TextAttributes() .font(name: "ChalkboardSE-Bold", size: 24) .foregroundColor(.red) return NSAttributedString(string: inputString, attributes: attributes)&#125;attributedStringWithTextAttributes("Hello TextAttributes") ConverterApp在这个项目中, 对文件移动不同target进行了一些实践, 需要注意的是 在目前版本的Xcode(10.1)下, 直接移动普通文件(.swift)到另一个target的目录下, 会直接修改该文件所绑定的target, 但是对.xib文件而言, Xcode不会不会自动修改, 需要我们手动修改修改完编译, 会提示以下信息: 1Could not find a storyboard named 'Temperature' in bundle NSBundle ... 这是因为移动过后的xib文件就不在main bundle中了, 还需要对之前的引用进行修改 在playground中使用这个viewcontroller 123456let frameworkBundle = Bundle(identifier: "com.razeware.ConverterKit")let storyboard = UIStoryboard(name: "Temperature", bundle:frameworkBundle)let viewController = storyboard.instantiateInitialViewController()!// 展示viewController.view 注意 在playground中 instantiate一个控制器会默认将其设置为 768 * 1024的尺寸 为了解决这个尺寸问题, 直接修改frame是不起作用的, 我们应该讲live view 直接设置为 viewcontroller1PlaygroundPage.current.liveView = viewController 苹果文档里给出了可以这么操作的缘由 同时, 在xib中选中了什么设备/机型 此处就会显示对应的尺寸. Tips页内锚点链接实现:1234567[title](#41) &lt;h3 id="41"&gt;title&lt;/h3&gt; 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。如果目标是标题类型(#前缀), 还可以直接使用[描述](#标题内容)来直接跳转. 试一下:跳转到Algorithm ShareEffective Dart: API 设计]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS Week 1]]></title>
    <url>%2F2019%2F03%2F26%2FARTS-Week-1%2F</url>
    <content type="text"><![CDATA[AlgorithmNo.2: Add Two Numbers原题:You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example:123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 解答:1234567891011121314151617181920212223242526272829public class ListNode &#123; public var val: Int public var next: ListNode? public init(_ val: Int) &#123; self.val = val self.next = nil &#125;&#125;class Solution &#123; func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123; var carry = 0, p = l1, q = l2 var dummy = ListNode(0) var node = dummy while p != nil || q != nil &#123; carry += p?.val ?? 0 carry += q?.val ?? 0 node.next = ListNode.init(carry % 10) node = node.next! carry = carry / 10 p = p?.next q = q?.next &#125; if carry &gt; 0 &#123; node.next = ListNode.init(carry) &#125; return dummy.next &#125;&#125; ReviewSwift Playgrounds in Depth(Part One)原文: https://www.raywenderlich.com/4345-swift-playgrounds-in-depth 这篇文章讲述了一些基础性的playground使用技巧,部分已失效, 但总体还是不错的, 用来查漏补缺, 总结了以下技巧. LiveViews.playgroundPlayground Page: Basic Live ViewliveView的使用:123import PlaygroundSupportPlaygroundPage.current.liveView = view 打开Assistant editor(⌥⌘Enter)就可以看到实时视图. IndefiniteExecution.playgroundPlayground Page: Spring Animation调用1PlaygroundPage.current.finishExecution() 就会直接停止执行当前页面. Playground Page: PlaygroundLiveViewable遵守并实现PlaygroundLiveViewable的对象就可以被设置成为PlaygroundPage.current.liveView IndefiniteExecution.playground通过PlaygroundPage.current.needsIndefiniteExecution = true来手动接管page的终止.在使用PlaygroundPage.current.finishExecution()来手动停止page. 注意,在当前版本的playground中(Xcode Version 10.1 (10B61))已经支持GCD的处理. SharedPlaygroundData.playgroundPlayground Page: Writing to a Fileplaygrounds直接写文件会报错误:1Write Error: You don’t have permission to save the file 1you can only write to the ~/Documents/ Shared Playground Data folder that is accessible via the playgroundSharedDataDirectory global variable in the PlaygroundSupport module. 在写入前, 先确保该文件夹已经存在,否则:1mkdir ~/Documents/Shared\ Playground\ Data 然后12 let fileURL =playgroundSharedDataDirectory.appendingPathComponent(filename) Playground Page: Reading from a File#fileLiteral(resourceName: “CoreImageFilterNames.txt”) 拖到项目中后便可使用这个字面量加载文件(已失效). TipsXcode10目前已经不支持直接使用Assets中素材的名字来直接创建Image Literal了, 现在可行的方案是先敲出Image在自动联想出Image Literal, 然后使用, 再点击出现的占位图选中自己想使用的素材, 比之前的麻烦了好多. ShareFlutter越来越火了, 作为Native开发人员, 我觉得首先要巩固自己的护城河, 将Native 和 计算机的基础知识打牢, 然后在以开放的态度面对新技术. 同时, 在学习的时候应该多实践, 没有业务需求上的匹配, 就强制让自己造简单轮子学习.]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC与Swift混编项目迁移到Swift4.2小记]]></title>
    <url>%2F2019%2F02%2F27%2FOC%E4%B8%8ESwift%E6%B7%B7%E7%BC%96%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB%E5%88%B0Swift4-2%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言自从Xcode10正式版发布之后, 先吃螃蟹的朋友赞叹了Dark Mode的惊艳, 同时也报告说, 打包上传到APPStroe后, 监测到线上 iOS9.3设备大面积crash的记录, 最后被证实是Xcode10的问题. 出于此原因考虑, 我便一直在使用Xcode9.4.1 及 Swift4进行混编项目的开发. 然而每每使用低版本的Xcode打包上传APPStore时, 就会收到苹果的官方警告邮件 如邮件内容所示, 到2019年的3月份便不可以再使用低版本Xcode进行打包上传操作了. 于是, 我只好开始了迁移之路. 开始迁移使用当前 Xcode10.1(10B61)打开之后, 在Build Setting中搜索 Swift Language Version, 将对应的值改为Swift 4.2,然后开始编译, 此时会出现非常多的Error, 多为ABI的变动, 根据提示进行修改即可. AVAudioSession的更改然而有一处例外:当项目中通过Swift使用了 AVAudioSession setCategory这个方法时, 会被告知方法在Swift中不可用.跳转才发现 API已经变化成了123/* set session category and mode with options */ @available(iOS 10.0, *) open func setCategory(_ category: AVAudioSession.Category, mode: AVAudioSession.Mode, options: AVAudioSession.CategoryOptions = []) throws 为了兼容低版本, 思来想去, 比较合适的方案就是使用OC编写一个AVAudioSession的分类用来桥接:1234567891011121314151617181920212223242526272829// AVAudioSession+Swift.h:@import AVFoundation;NS_ASSUME_NONNULL_BEGIN@interface AVAudioSession (Swift)- (BOOL)swift_setCategory:(AVAudioSessionCategory)category error:(NSError **)outError NS_SWIFT_NAME(setCategory(_:));- (BOOL)swift_setCategory:(AVAudioSessionCategory)category withOptions:(AVAudioSessionCategoryOptions)options error:(NSError **)outError NS_SWIFT_NAME(setCategory(_:options:));@endNS_ASSUME_NONNULL_END// AVAudioSession+Swift.m:#import "AVAudioSession+Swift.h"@implementation AVAudioSession (Swift)- (BOOL)swift_setCategory:(AVAudioSessionCategory)category error:(NSError **)outError &#123; return [self setCategory:category error:outError];&#125;- (BOOL)swift_setCategory:(AVAudioSessionCategory)category withOptions:(AVAudioSessionCategoryOptions)options error:(NSError **)outError &#123; return [self setCategory:category withOptions:options error:outError];&#125;@end 然后在你项目的&lt;#target_name#&gt;-Bridging-Header.h中import这个分类:1#import "AVAudioSession+Swift.h" 然后就可以像之前一样调用了.1try AVAudioSession.sharedInstance().setCategory(.playback) While deserializing SIL vtable for ‘Class’ in module ‘module’ error: Abort trap: 6这类问题分两种, 一种是module是其他的target, 如Pods中的, 另一种是 module是自己的创建的target. 第一种第一种 只需要将Error所指向的三方库更新到最新版本即可, Xcode10已经发布了快半年了, 这些问题之前也有, 半年的时间, 基本上流行的三方库都已经适配了Swift4.2 第二种而第二种比较棘手, 一般都是由于 Error中的Class所指向的类, 自己是Swift类, 但是却继承自Objective-C声明编写的类.我在自己试过一些微调之后发现于事无补, 所以只好将出错的类使用Objective-C重写, 然后在桥接文件中引入, 好在报错的不多, 没用费太多力气. 其他奇怪的错误迁移完成后 项目跑起来时, 还会出现很多奇怪的问题.比如调用了某个方法A 会报unrecognize selector *,以及莫名的函数调用, 如:(setupNavibar函数中并没用调用任何初始化构造函数)这类错误, 一般跟以上的俩种问题是一个本质, 需要自己仔细区别, 然后做出相应更新/更改即可. 除开以上的问题, 项目编译时还会在Pods引用的第三方的类中报ABI需要修改的Error, 这时, 只需要找到队形的Target, 在其Build Settings中修改 Swift Language Version为其对应版本即可. 最后, 希望将来适配Swift5时, 不要有这么多坑了…]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>Objective-C</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网穿透及端口转发]]></title>
    <url>%2F2018%2F07%2F17%2F%E5%9F%BA%E4%BA%8ESSH%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8F%8A%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[前言在上一篇文章中, 我介绍了如何通过docker搭建redmine项目管理平台, 然而此时 redmine仅仅只能在内网上才能访问到, 接下来这篇就介绍下如何通过内网穿透和端口转发来让我们随心所欲的访问到. 设备 机器代号 机器描述 账户 地址 ssh/sshd 端口 Server 公网服务器 server server.site 29245 Base 个人电脑(位于NAT之后) userb 127.0.0.1 22 Slave 垫显示器的MacMini(位于NAT之后) users 127.0.01 22 实现实现内网穿透及端口转发有很多手段途径, 下面我只介绍两种较简单和常用的.一种是 基于 SSH 的另一种是 基于 Frp 的 基于SSH的内网穿透及端口转发 SSH反向隧道这种手段实质上是由Slave向Server主动建立一个SSH通道, 将Server的某一个端口转发到Slave的SSH端口(22)上.我们以Server的54345端口为例进行转发: 12345678ssh -fN -R 54345:localhost:22 server@server.site -p 29245# -f Requests ssh to go to background just before command execution. 让该命令后台运行 .# -n Redirects stdin from /dev/null (actually, prevents reading from stdin).# -N Do not execute a remote command. 不执行远程命令 .# -R 远程转发 上面, 我们将Server的54345端口转发到了Slave的22端口上, 只要这个隧道不关闭, 我们就可以在Base上通过访问A的54345端口来连接Slave的22端口上. 12# 在Base机器上ssh slave@server.site -p 54345 隧道的维持由于SSH存在超时关闭的可能, 而一旦链接关闭, 隧道便无法维持, 那么Base也就无法随心所欲的访问Slave了, 为此我们需要一种方案来提供一条稳定的SSH 反向隧道. 一个最简单的方法就是autossh，这个软件会在超时之后自动重新建立SSH 隧道. 安装SSH12# MacMini- MacOSbrew install autossh 配置autossh1234567autossh -M 5678 -fN -o &quot;PubkeyAuthentication=yes&quot; -o &quot;StrictHostKeyChecking=false&quot; -o &quot;PasswordAuthentication=no&quot; -o &quot;ServerAliveInterval 60&quot; -o &quot;Serv erAliveCountMax 3&quot; -R 54345:127.0.0.1:22 server@server.site -p 29245# “-M 5678” 选项指定中继服务器上的监视端口，用于交换监视 SSH 会话的测试数据。中继服务器上的其它程序不能使用这个端口。# “-o XXXX” 选项让 ssh：# * 使用密钥验证，而不是密码验证。# * 自动接受（未知）SSH 主机密钥。# * 每 60 秒交换 keep-alive 消息。# * 没有收到任何响应时最多发送 3 条 keep-alive 消息。 如此, 便可保证在不重启Slave的情况下的稳定SSH链接. 端口转发到docker的服务在上一篇文章中我们在Slave机器上对docker的物理机3000端口与虚拟机的3000端口做的了映射, 所以外部用户可以通过3000端口直接访问docker的redmin服务.此时, 只需要通过SSH隧道将Slave的3000端口转发到Server的某个端口上, 就可以了. 1ssh -fN -R 3000:localhost:3000 server@server.site -p 29245 如此, 我们便可以通过访问server.site:3000端口就可以直接访问到位于Slave的redmine服务. 基于Frp的内网穿透及端口转发 frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议. frp可以利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务.对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口.也可以利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机. 安装frpServer(公网服务器)与Slave(内网服务器)都需要安装frp, 下载地址是https://github.com/fatedier/frp/releases. 123456# Linuxwget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz# MacOScurl -OL https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_darwin_amd64.tar.gz 解压1tar -zxvf frp_0.21.0_linux_amd64.tar.gz Server端配置 基本配置 在Server端中下载好frp, 解压完成后就cdj进入, 然后编辑frps.ini文件, 添加如下代码.1234567[common]#与客户端绑定的进行通信的端口bind_port = 7000#http的访问端口vhost_http_port = 80#https的访问端口(如果需要的话)vhost_https_port = 8080 然后我们只需要运行如下命令就可以了1./frps -c ./frps.ini &amp;! 开机自动运行&amp;自动重连 这里以通过systemd来初始化为例, 我们只需要编写一个service文件就可以(其他情况请参看https://github.com/fatedier/frp/issues/176) 12345// 进入相关文件cd /etc/systemd/system/// 创建service文件touch frps.service 然后将如下代码写入到frps.service中 1234567891011121314[Unit]Description=frps daemonAfter=syslog.target network.targetWants=network.target[Service]Type=simpleExecStart=/home/ubuntu/frp/frps -c /home/ubuntu/frp/frps.ini &amp; #这里地址需要改成自己frp的地址Restart= alwaysRestartSec=1minExecStop=/usr/bin/killall frps[Install]WantedBy=multi-user.target 最后启用并启动服务: 12345sudo systemctl enable frpssudo systemctl start frps// 查看运行状态sudo systemctl status frps 如果服务的状态是active就表示运行成功了. 客户端(Slave)配置1.基本配置 下载解压后进入目录, 编辑frpc.ini文件:123456789101112131415161718192021[common]server_addr = server.site # 如: 123.206.87.36server_port = 7000 # 与Server端中frps.ini文件中设置的一样.[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 20022[jenkins]type = tcplocal_ip = 127.0.0.1local_port = 8080remote_port = 28080[redmine]type = tcplocal_ip = 127.0.0.1local_port = 3000remote_port = 23000 2.后台执行 1./frpc -c ./frpc.ini &amp;! 在frpc.ini文件中分别配置了三对映射, 这时我们便可以通过访问映射好的ip地址来访问到Base(客户端)的服务.访问redmine 参考实战 SSH 端口转发 深入浅出的介绍了SSH端口转发的原理. frp文档]]></content>
      <tags>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13个小技巧]]></title>
    <url>%2F2017%2F09%2F18%2F%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[13个小技巧1. Spaced Repettion 间歇重复为了最大化你的学习效率, 短时间学习, 并且重复练习.有规律的学习计划、作息, 这样会更有效率. 2. Find Your Own Style3. Good Night Sleep睡觉与做梦是处理和存储新信息至关重要的部分.一项哈佛大学的研究显示, 那些在记忆学习资料后睡了一晚好觉的学生, 比那些早上学习晚上测试的学生的效果要好35%. 4. Focus 关掉自己的手机. 去图书馆一样安静的地方. 5. Pomodoro Technique 6. Hard Stuff First大多数人在早上有着最强的意志力, 一旦你完成了最难的事, 接下来一整天对都会感觉更好. 可能会因此得到更多的动力 激发自己去完成其他的事项. 7. Exercise Meditate And Converse有一些活动被证实可以使你的大脑增长. 8. Go Place换个环境进行学习记忆 效果会好的多. 9. Take Fun Seriously 10. Space Your Studies利用记忆的特性(如艾宾浩斯遗忘曲线所描述的那样), 定期经常回顾学到的知识, 会得到更好的效果. 11. 30% Read, 70% Recite 12. Instant Self Test 即刻自我检讨因为大脑对于回想比记忆更难, 所以即时的强化可以有效的提高之后的记忆效果. 13. Don’t Forceit不要强迫, 如果此时不想学习, 休息下, 去做其他事.]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用宏定义实现枚举转字符串]]></title>
    <url>%2F2017%2F08%2F30%2F%E5%88%A9%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[前言在我们编码过程中,枚举会经常用到, 尤其是用来表示多种状态时.然而, 在OC中, 对枚举进行打印调试 或者 拼接方法 的操作的编程体验是非常差的. 例子以下这种情况你应该会经常遇到: 123456789// 你工作时的几种状态typedef NS_ENUM(NSInteger, WorkStatus) &#123; /** 摸鱼*/ WorkStatusUnKnown, /** 认真工作*/ WorkStatusWorking, /** 休息*/ WorkStatusSleeping,&#125;; 当我们想要打印这个枚举时, 默认输出的是这个枚举标识符所对应的值, 这样的效果是非常不理想的, 只输出数字,不直观(我们之所以使用枚举来定义状态, 不就是要直观的表示吗?), 为了达到直观这一目的, 写一个将枚举标识符转换成字符串的方法就势在必得了: 12345678910111213141516171819- (NSString *)WorkStatusDescription:(WorkStatus)status&#123; NSString *desc = nil; switch (status) &#123; case WorkStatusUnKnown: desc = @"WorkStatusUnKnown"; break; case WorkStatusWorking: desc = @"WorkStatusWorking"; break; case WorkStatusSleeping: desc = @"WorkStatusSleeping"; break; default: desc = @"NoOne"; break; &#125; return desc;&#125; 问题这样操作, 也许解决了不直观的问题, 但是细看之下还是有两点很大的问题. 在某一个类的空间内声明定义转换方法, 对于作用域外(其他类)的地方使用非常不便. 当对枚举的标识符进行增删改操作时, 必须也要同时修改转换方法内的代码, 非常不灵活. 优化优化问题1针对于 问题 1, 我们可以通过在头文件中声明定义函数来解决: 1234567891011121314151617181920static NSString * WorkStatusDescription(WorkStatus status) __attribute__((unused));static NSString * WorkStatusDescription(WorkStatus status) &#123; NSString *desc = nil; switch (status) &#123; case WorkStatusUnKnown: desc = @"WorkStatusUnKnown"; break; case WorkStatusWorking: desc = @"WorkStatusWorking"; break; case WorkStatusSleeping: desc = @"WorkStatusSleeping"; break; default: desc = @"NoOne"; break; &#125; return desc;&#125; 有两点需要解释: 使用static可以防止发生函数重复声明定义的错误. (使用NS_INLINE也可以.) __attribute__((unused)) 表示告诉编译器忽略Unused Warning. 优化问题2解决 问题 2 的关键在于如何将一个枚举标识符灵活的转换成字符串. 根据这个思路, 很自然的就可以联想到 使用 宏定义中 # 可以将参数转换成字符串的特性来解决. 123456789101112131415161718192021222324252627// 定义枚举标识符和其对应的值的宏#define ENUM_VALUE(name,assign) name assign,// 将枚举标识符转换成字符串的宏#define ENUM_CASE(name,assign) case name: return @#name;// 将字符串转换为枚举标识符的宏#define ENUM_STRCMP(name,assign) if ([string isEqualToString:@#name]) return name;/// 声明函数 及 定义枚举#define DECLARE_ENUM(EnumType,ENUM_DEF) \typedef NS_ENUM(NSUInteger, EnumType) &#123; \ ENUM_DEF(ENUM_VALUE) \&#125;; \static NSString *stringFrom##EnumType(EnumType value) __attribute__((unused)); \static EnumType EnumType##FromString(NSString *string) __attribute__((unused)); \static NSString *stringFrom##EnumType(EnumType value) &#123; \ switch(value) &#123; \ ENUM_DEF(ENUM_CASE) \ default: return @""; \ &#125; \&#125; \\static EnumType EnumType##FromString(NSString *string) &#123; \ ENUM_DEF(ENUM_STRCMP) \ return (EnumType)0; \&#125; 为了一气呵成, 已经将针对于 问题 1 优化合并到上面这个代码块中. 使用12345678910// 导入定义宏所在的头文件.#import "enum_generator.h"// 使用定义的宏声明枚举#define WorkStatus(XX) \XX(WorkStatusUnKnown,) \XX(WorkStatusWorking,) \XX(WorkStatusSleeping,=50)// 生成定义的枚举 与 转换方法.DECLARE_ENUM(WorkStatus,WorkStatus) 为了更直观的感受, 我们进入预编译阶段, 查看宏生成的代码(为了看起来清晰 已经进行手动换行):1234567891011121314151617181920212223242526272829// DECLARE_ENUM(WorkStatus,WorkStatus) 所生成的代码typedef enum WorkStatus : NSUInteger WorkStatus; enum WorkStatus : NSUInteger &#123; WorkStatusUnKnown , WorkStatusWorking , WorkStatusSleeping =50,&#125;;static NSString *stringFromWorkStatu(WorkStatus value) __attribute__((unused));static WorkStatus WorkStatusFromString(NSString *string) __attribute__((unused));static NSString *stringFromWorkStatus(WorkStatus value) &#123; switch(value) &#123; case WorkStatusUnKnown: return @"WorkStatusUnKnown"; case WorkStatusWorking: return @"WorkStatusWorking"; case WorkStatusSleeping: return @"WorkStatusSleeping"; default: return @""; &#125;&#125;static WorkStatus WorkStatusFromString(NSString *string) &#123; if ([string isEqualToString:@"WorkStatusUnKnown"]) return WorkStatusUnKnown; if ([string isEqualToString:@"WorkStatusWorking"]) return WorkStatusWorking; if ([string isEqualToString:@"WorkStatusSleeping"]) return WorkStatusSleeping; return (WorkStatus)0;&#125; 测试123456789WorkStatus testWorkStatus = WorkStatusUnKnown;NSLog(@"workstatus is: %@", stringFromWorkStatus(testWorkStatus));if (testWorkStatus == WorkStatusFromString(@"WorkStatusUnKnown")) &#123; NSLog(@"确认在摸鱼");&#125;// 输出:// workstatus is: WorkStatusUnKnown// 确认在摸鱼 More灵感来自 https://stackoverflow.com/questions/147267/easy-way-to-use-variables-of-enum-types-as-string-in-c/202511#202511 Demo https://github.com/onekyle/EnumStringConvert/tree/master 如果你有更好的想法 请不吝赐教.]]></content>
      <tags>
        <tag>Objective-C</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxSwift-step(二)]]></title>
    <url>%2F2017%2F08%2F15%2FRxSwift-step-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[12-理解重复订阅Observable的行为share() - 不要反复订阅同一个Observable1234let numbers = Observable.of(1, 2, 3, 4, 5)_ = numbers.subscribe(onNext: &#123; print($0) &#125;)_ = numbers.subscribe(onNext: &#123; print($0) &#125;) 假设，我们希望这两次订阅实际上使用的是同一个Observable，但执行一下就会在控制台看到，打印了两次1 2 3 4 5，也就是说每次订阅，都会产生一个新的Observable对象，多次订阅的默认行为，并不是共享同一个序列上的事件。 为了在多次订阅的时候共享事件，我们可以使用share operator，为了观察这个效果，我们把numbers的定义改成这样：1let numbers = Observable.of(1, 2, 3, 4, 5).share() scan operator1234567891011121314151617_ = selectedPhotos.scan([]) &#123; (photos: [UIImage], newPhoto: UIImage) in var newPhotos = photos if let index = newPhotos.index(where: &#123; newPhoto == $0 &#125;) &#123; newPhotos.remove(at: index) &#125; else &#123; newPhotos.append(newPhoto) &#125; return newPhotos &#125;.subscribe(onNext: &#123; (photos: [UIImage]) in self.images.value = photos &#125;, onDisposed: &#123; print("Finished choose photo memos.") &#125;) 上述的scan作用类似于集合类型中的reduce. 13-更好的处理授权提示iOS的用户授权动作是异步的.为了能在用户完成授权操作之后继续更新UI，我们得先把授权的结果封装成一个Observable。实际上，这个Observable只可能是下面三种情况： 如果用户已授权，事件序列就是：.next(true)，.completed()； 如果用户未授权，序列的第一个事件就一定是.next(false)。然后，如果用户拒绝授权，序列中的事件就是：.next(false)和.completed。否则，就是.next(true)和.completed； 订阅用户的授权结果订阅的部分，应该写在PhotoCollectionViewController.viewDidLoad方法里。先别着急，这个过程要比我们想象的复杂一点，我们不能直接订阅isAuthorized的onNext并处理true/false的情况，因为单一的事件值并不能反映真实的授权情况。按照之前分析的： 授权成功的序列可能是：.next(true)，.completed或.next(false)，.next(true)，.completed； 授权失败的序列则是：.next(false)，.next(false)，.completed；因此，我们需要把isAuthorized这个事件序列处理一下，分别处理授权成功和失败的情况。 订阅成功事件首先来订阅授权成功事件，我们只要忽略掉事件序列中所有的false，并读到第一个true，就可以认为授权成功了。使用“过滤型”operator可以轻松完成这个任务： 123456789101112131415override func viewDidLoad() &#123; super.viewDidLoad() ... // PHPhotoLibrary.isAuthorized返回一个Observable&lt;Bool&gt; let isAuthorized = PHPhotoLibrary.isAuthorized isAuthorized .skipWhile &#123; $0 == false &#125; .take(1) .subscribe(onNext: &#123; [weak self] _ in // Reload the photo collection view &#125;) .addDisposableTo(bag)&#125; 可以看到, 上面的代码中, 使用skipWhile忽略了所有false, 并且读取到了之后第一个true. 订阅失败事件接下来，我们处理拒绝授权的情况。这种情况相比成功简单一些，因为它对应的事件序列只有一种情况：.next(false)，.next(false)，.completed。因此，我们只要对事件序列中所有元素去重之后，订阅最后一个.next事件，如果是false，就可以确定是用户拒绝授权了。因此，在订阅成功授权的代码后面，继续添加下面的代码：123456789101112131415161718override func viewDidLoad() &#123; super.viewDidLoad() ... isAuthorized .distinctUntilChanged() .takeLast(1) .filter&#123; $0 == false &#125; .subscribe(onNext: &#123; [weak self] _ in self?.flash(title: "Cannot access your photo library",message: "You can authorize access from the Settings.", callback: &#123; [weak self] _ in self?.navigationController?.popViewController(animated: true) &#125;)) &#125;) .addDisposableTo(bag)&#125; 14-了解常用的transform operatorstoArraytoArray，这可以说是最简单的Transform operator。它把Observable&lt;T&gt;中所有的事件值，在订阅的时候，打包成一个Array&lt;T&gt;返回给订阅者.有一点要注意的是，toArray的转换，是在订阅的时候，根据当前Observable中的值一次性完成转换的，后续的事件订阅则不会再进行转换: 123456789101112let numbers = PublishSubject&lt;Int&gt;()numbers.asObservable() .toArray() .subscribe(onNext: &#123; print($0) &#125;).addDisposableTo(bag)numbers.onNext(1)numbers.onNext(2)numbers.onNext(3) 对于这个例子来说，在订阅的时候，使用了toArray，但此时，numbers中没有任何值，toArray变换出来的，就是个空数组。即便之后numbers中发生了事件123，但是，我们订阅的，已经不是numbers，而是numbers在订阅的时候转换成的Observable&lt;Array&lt;Int&gt;&gt;，用序列图来表示是这样的： 我们订阅的代码是图中红色的Observable，因此，也就不会打印任何内容了。 scan 123456Observable.of(1, 2, 3).scan(0) &#123; accumulatedValue, value in accumulatedValue + value &#125;.subscribe(onNext: &#123; print($0) &#125;).addDisposableTo(bag) 输出为 1、3、6.但是，就想上面图中展示的那样，和toArray不同的是，scan在Observable每次有事件的时候都会执行. 转换事件类型的map12345Observable.of(1, 2, 3).map &#123; value in value * 2&#125;.subscribe(onNext: &#123; print($0)&#125;).addDisposableTo(bag) 15-为什么RxSwift也需要flatMapflatMap在集合中使用到, 在Optional中也使用到, 到了RxSwift也用到它, 但是在这些不同的领域中, flatMap往往又表示了不同的含义. 在RxSwift中是这么定义flatMap的: Transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable. 翻译过来就是 将由Observable 发送来的Item转换成一个个Observables, 然后再展开, 将所有Observables的发射序列合并成一个Observable. 把序列中的事件变成新的Observable来看下RxSwift官方demo中提供的例子: 123456struct Player &#123; var score: Variable&lt;Int&gt; &#125; let 👦🏻 = Player(score: Variable(80)) let 👧🏼 = Player(score: Variable(90)) 然后创建一个Variable, 然后订阅它12345678let player = Variable(👦🏻)player.asObservable() .flatMap &#123; $0.score.asObservable() &#125; // Change flatMap to flatMapLatest and observe change in printed output .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)👦🏻.score.value = 85 // 输出 80 85 👦🏻是Player序列中发生的事件, 通过flatMap我们把它变成了一个Observable&lt;Int&gt;, 这就是flatMap定义的前半句话的含义: Transform the items emitted by an Observable into Observables. ### 合并所有Observables的发射序列 接下来, 我们把👧🏼加入, 注意下👧🏼添加的位置1234567player.value = 👦🏻 // 输出80👦🏻.score.value = 85 // 输出85player.value = 👧🏼 // 输出90👧🏼.value = 95 // 输出95]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxSwift-step by step 1-10]]></title>
    <url>%2F2017%2F08%2F14%2FRxSwift-step%2F</url>
    <content type="text"><![CDATA[写在前面这一系列笔记用于对泊学网RxSwift-step by step课程进行总结和摘选, 仅用于个人学习记忆. 笔记01-异步事件是以时间为索引的常量队列以时间为索引的常量队列的方式 这也是引入RxSwift的目的 02-安装RxSwift的三种不同的方式学习使用playground来编写文档 安装方式 1.mac环境下使用cocoapods安装 2.非mac环境下可以使用 SPM 安装 在编辑SPM自动生成的package.swift文件, 修改 然后退出编辑 执行swift build (会自动下载RxSwift 然后 自动执行build)3.手动添加 将RxSwift(只是一个project)下载到当前目录下(这个指令值得深究) 03-RxSwift中的那些”术语”到底在说什么?我们创建的Observable, 表达的是异步操作, Observable中的每一个元素, 都可以理解为一个异步发生的事件.因此,当我们对Observable调用map和filter方法时,只表示我们要对事件序列中的元素进行处理的逻辑,而并不会立即对Observable中的元素进行处理. operator对Observable的加工是在订阅的时候发生的.这种只有在订阅的时候才emit事件的Observable,有一个专有的名字,叫做Cold Observable. 言外之意,就是也有一种Observable是只要创建了就会自动emit事件的,它们叫做Hot Observable.在后面的内容中,我们会看到这类事件队列的用法. 对于有限观察序列, 执行到头时 资源就自动释放, 但是有时有些观察序列并非有限 如 timer序列. 所以就需要我们对其进行手动释放, 当然, RxSwfit也提供另一种方式, DisposeBag实例. 调用disposed(by: ) 将Observable与 一个 DisposeBag绑定起来. 然后当这个bag实例销毁时, 所有其绑定的订阅者都将取消订阅 并 回收资源. 04 理解create和debug operator理解 create函数中的subcribe参数的意义: 并非订阅, 而是 描述如何向订阅者发送订阅的消息 订阅 操作 do 旁路特性 debug(). 为Observable执行debug()操作, 会将所以订阅到的消息打印出来, 05 四种Subject的基本用法上节末尾,我们提到了Subject.既然它可以同时作为Observable 和 Observer,我们就直奔主题,从一个叫做PublishSubject的对象开始,感受下Subject的用法: PublishSubject1234567let subject = PublishSubject&lt;String&gt;()subject.onNext("Episode1 updated")// 第三,当我们把subject当作Observable的时候,订阅它的代码和订阅普通的Observable完全一样：let sub1 = subject.subscribe(onNext: &#123; print("Sub1 - what happened: \($0)")&#125;) BehaviorSubject如果你希望Subject从会员制变成试用制,就需要使用BehaviorSubject. ReplaySubjectReplaySubject的行为和BehaviorSubject类似,都会给订阅者发送历史消息.不同地方有两点： ReplaySubject没有默认消息,订阅空的ReplaySubject不会收到任何消息； ReplaySubject自带一个缓冲区,当有订阅者订阅的时候,它会向订阅者发送缓冲区内的所有消息； 12// ReplaySubject缓冲区的大小,是在创建的时候确定的：let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 2) Variable除了事件序列之外,在平时的编程中我们还经常需遇到一类场景,就是需要某个值是有”响应式”特性的.为了方便这个操作,RxSwift还提供了一个特殊的subject,叫做Variable. 1234567891011121314// 我们可以像定义一个普通变量一样定义一个Variable：let stringVariable = Variable("Episode1")// 当我们要订阅一个Variable对象的时候,要先明确使用asObservable()方法.而不像其他subject一样直接订阅：let stringVariable = Variable("Episode1")let sub1 = stringVariable .asObservable() .subscribe &#123; print("sub1: \($0)")&#125;// 而当我们要给一个Variable设置新值的时候,要明确访问它的value属性,而不是使用onNext方法：stringVariable.value = "Episode2" 最后要说明的一点是,Variable只用来表达一个”响应式”值的语义,因此,它有以下两点性质： 绝不会发生.error事件； 无需手动给它发送.complete事件表示完成； 07 TodoDemo2资源被正常回收了么？此时,尽管已经可以正常添加Todo了,但是如果你足够细心就可以发现,控制台并没有打印Finsih adding a new todo.的提示.也就是说,在dismiss了TodoDetailViewController之后,todoSubject并没有释放,我们应该在某些地方导致了资源泄漏. 为了进一步确认这个问题,在Podfile中添加下面的内容： 1234567891011post_install do |installer| installer.pods_project.targets.each do |target| if target.name == 'RxSwift' target.build_configurations.each do |config| if config.name == 'Debug' config.build_settings['OTHER_SWIFT_FLAGS'] ||= ['-D', 'TRACE_RESOURCES'] end end end endend 简单来说,就是找到项目中的RxSwift target,在它的Debug配置中,添加-D TRACE_RESOURCES编译参数,并在Termianl中重新执行pod install更新下RxSwift.然后,在TodoDetailViewController的viewWillAppear方法中,添加下面的代码： 12345678override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) todoName.becomeFirstResponder() todoItem = TodoItem() print("Resource tracing: \(RxSwift.Resources.total)")&#125; 但事情至此还没结束,可能你会觉得这样写代码感觉怪怪的,甚至有些危险.因为我们要依赖一个Controller（TodoDetailViewController）中的某个属性（bag）才能得以工作正常.而常规的开发经验通常告诉我们,如此密切的耦合关系通常是各种问题滋生的温床.这至多,只能算一个”非主流”的办法. 那么,更”主流”的办法是什么呢？ 希望你还记得,对于一个Observable来说,除了所有订阅者都取消订阅会导致其被回收之外,Observable自然结束（onCompleted）或发生错误结束（onError）也会自动让所有订阅者取消订阅,并导致Observable占用的资源被回收. 因此,当TodoDetailViewController dismiss之后,实际上我们也不会再使用它添加新的Todo了,这时,我们应该给todoSubject发送onCompeleted事件,明确告知RxSwift,这个事件序列结束了. 08 ToDoDemo3可以看到,是否同步成功是通过调用completionHandler通知的,仿照之前的思路,我们可以让syncTodoToCloud返回一个Observable&lt;URL&gt;,其中的URL是iCloud保存在本地的路径：123456789101112131415161718func syncTodoToCloud() -&gt; Observable&lt;URL&gt; &#123; // ... return Observable.create(&#123; observer in plist.save(to: cloudUrl, for: .forOverwriting, completionHandler: &#123; (success: Bool) -&gt; Void in if success &#123; observer.onNext(cloudUrl) observer.onCompleted() &#125; else &#123; observer.onError(SaveTodoError.cannotCreateFileOnCloud) &#125; &#125;) return Disposables.create() &#125;)&#125; 要特别强调的是：onCompleted对于自定义Observable非常重要,通常我们要在onNext之后,自动跟一个onCompleted,以确保Observable资源可以正确回收. 09 常用的忽略事件操作符事例代码1234567891011121314151617181920example("ignoreElements") &#123; let tasks = PublishSubject&lt;String&gt;() let bag = DisposeBag() tasks.subscribe &#123; print($0) &#125; .addDisposableTo(bag) tasks.onNext("T1"); tasks.onNext("T2"); tasks.onNext("T3"); tasks.onCompleted();&#125;/*正常输出:next(T1)next(T2)next(T3)completed */ Ignore elementssignoreElements 会忽略序列中所有的.next事件. 将事例代码中的订阅部分替换成以下:12345678tasks.ignoreElements() .subscribe &#123; print($0) &#125; .addDisposableTo(bag)/*输出:completed*/ 用序列图描述, 就是这样的: skipskip可以用来忽略事件序列中特定个数的.next.1234567891011tasks.skip(2) .subscribe &#123; print($0) &#125; .addDisposableTo(bag)/*输出:next(T3)completed*/ 用序列图描述, 就是这样的: skipWhile / skipUntilskipWhile除了可以忽略指定个数的事件外,我们还可以通过一个closure自定义忽略的条件,这个operator叫做skipWhile.但它和我们想象中有些不同的是,它不会”遍历”事件序列上的所有事件,而是当遇到第一个不满足条件的事件之后,就不再忽略任何事件了. 使用如下代码替换订阅部分代码:1234567tasks.skipWhile &#123; $0 != "T2"&#125;.subscribe &#123; print($0)&#125;.addDisposableTo(bag) 输出:123next(T2) // 注意还是会订阅到T2的事件next(T3)completed  skipUntil另外一个和skipWhile类似的operator是skipUntil,它不用一个closure指定忽略的条件,而是使用另外一个事件序列中的事件.例如,我们先把代码改成这样： 1234567891011121314let tasks = PublishSubject&lt;String&gt;()let bossIsAngry = PublishSubject&lt;Void&gt;()let bag = DisposeBag()tasks.skipUntil(bossIsAngry) .subscribe &#123; print($0) &#125; .addDisposableTo(bag)tasks.onNext("T1");tasks.onNext("T2");tasks.onNext("T3");tasks.onCompleted(); 执行一下就会看到,我们不会订阅到任何事件.这就是skipUntil的效果,它会一直忽略tasks中的事件,直到bossIsAngry中发生事件为止. 在T2与T3中插入如下代码1234tasks.onNext("T1");tasks.onNext("T2");bossIsAngry.onNext();tasks.onNext("T3"); 输出:12next(T3)completed 用序列图描述出来, 就是这样的: distinctUntilChangeddistinctUntilChanged可以用来忽略序列中连续 重复 的事件. 例如:123456789101112131415161718example("ignoreElements") &#123; let tasks = PublishSubject&lt;String&gt;() let bag = DisposeBag() tasks.distinctUntilChanged() .subscribe &#123; print($0) &#125; .addDisposableTo(bag) tasks.onNext("T1") tasks.onNext("T2") tasks.onNext("T2") tasks.onNext("T3") tasks.onNext("T3") tasks.onNext("T4") tasks.onCompleted()&#125; 由于T2和T3都存在连续重复的事件, 因此我们只能订阅到下面这样的结果12345next(T1)next(T2)next(T3)next(T4)completed 它的序列图是这样的:但是,如果把T2放到两个T3中间,此时就没有任何连续重复的事件了,我们就会订阅到所有任务. 10 常用的获取事件操作符elementAt1234567891011tasks.elementAt(1) .subscribe &#123; print($0) &#125; .addDisposableTo(bag)/*输出next(T2)completed*/ filter1234567891011tasks.filter &#123; $0 == "T2" &#125; .subscribe &#123; print($0) &#125; .addDisposableTo(bag)/* 输出:next(T2)completed*/ take除了选择订阅单一事件之外,我们也可以选择一次性订阅多个事件,例如,选择序列中的前两个事件： 12345tasks.take(2) .subscribe &#123; print($0) &#125; .addDisposableTo(bag) takeWhile/takeWhileWithIndex我们也可以用一个closure来指定”只要条件为true就一直订阅下去”这样的概念.例如,只要任务不是T3就一直订阅下去: 1234567tasks.takeWhile &#123; $0 != "T3" &#125; .subscribe &#123; print($0) &#125; .addDisposableTo(bag) 控制台输出:123next(T1)next(T2)completed takeWhileWithIndex的closure有两个参数，第一个是事件的值，第二个是事件在序列中的索引。它的语义和takeWhile是完全一样的，需要注意的仍旧是，在closure里写的，是读取事件的条件，而不是终止读取的条件. takeUntil1234567891011121314151617181920212223example("ignoreElements") &#123; let tasks = PublishSubject&lt;String&gt;() let bossHasGone = PublishSubject&lt;Void&gt;() let bag = DisposeBag() tasks.subscribe.takeUntil(bossHasGone) &#123; print($0) &#125; .addDisposableTo(bag) tasks.onNext("T1") tasks.onNext("T2") tasks.onNext("T3") tasks.onCompleted()&#125;tasks.onNext("T1")tasks.onNext("T2")bossHasGone.onNext()tasks.onNext("T3")tasks.onCompleted() 输出:123next(T1)next(T2)completed]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的数组]]></title>
    <url>%2F2017%2F07%2F31%2FSwift%E4%B8%AD%E7%9A%84%E5%85%A7%E5%BB%BA%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在Swift中, 最常用的集合类型非数组莫属了. 然而相较于Objective-C, Swift中数组有不小的变化. 基本的操作变化: 想要迭代数组？for x in array 想要迭代除了第一个元素以外的数组其余部分？for x in array.dropFirst() 想要迭代除了最后 5 个元素以外的数组？for x in array.dropLast(5) 想要列举数组中的元素和对应的下标？for (num, element) in collection.enumerated() 想要寻找一个指定元素的位置？if let idx = array.index { someMatchingLogic($0) } 除此之外, Swift为方便数组操作还添加了一系列高阶函数. map 和 flatMap — 如何对元素进行变换 filter — 元素是否应该被包含在结果中 reduce — 如何将元素合并到一个总和的值中 sequence — 序列中下一个元素应该是什么？ forEach — 对于一个元素，应该执行怎样的操作 sort，lexicographicCompare 和 partition — 两个元素应该以怎样的顺序进行排列 index，first 和 contains — 元素是否符合某个条件 min 和 max — 两个元素中的最小/最大值是哪个 elementsEqual 和 starts — 两个元素是否相等 split — 这个元素是否是一个分割符 这几个高阶函数使用一个函数作为参数, 将重复切杂乱的的代码, 如遍历等操作给剥离出来. 同时, 函数的命名也是非常严谨且浅显的, 非常值得回味其中的奥妙. 不但如此, 利用Swift编译器的一些特性(待详细描述), 我们可以写出异常简洁直观的代码:12345let numbers = Array.init(0..&lt;10)numbers.map &#123; $0 * $0 &#125;.filter&#123; $0 % 2 == 0 &#125; // [0, 4, 16, 36, 64]numbers.reduce(0, +) // 运算符也是函数, 所以可以这么写, 结果为 45 数组切片Swift中还允许我们通过下标来获取特定范围内的元素: 1234567let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]let streetsSlice = streets[2 ..&lt; streets.endIndex]print(streetsSlice)// Prints "["Channing", "Douglas", "Evarts"]"let index = streetsSlice.index(of: "Evarts") // 4print(streets[index!])// Prints "Evarts" 这是通过对 subscript 进行重载实现的, RandomAccessCollection协议的扩展中给出了方法的声明1public subscript(bounds: Range&lt;Self.Index&gt;) -&gt; RandomAccessSlice&lt;Self&gt; &#123; get &#125; 需要注意的是, 在上面的代码事例中, 获取 streetsSlice 实例关于 Evarts 的 index, 以及通过这个 index 获取的元素, 都是与开始的数组 streets 相匹配的. 所以, 可以猜测出 数组切片类型 ArraySlice 的子元素, 只不过是原数组的引用, 并通过两个属性 来记录其相对于原数组的 首尾偏移. 值类型与OC中的数组最大的不同, Swift中的 Array 是一个结构体类型, 本身具有不可变的特性, 即便我们可以使用 var 来声明一个可变的数组, 但是这个可变性只体现在变量本身上, 而不是指里面的值. 改变一个结构体变量的属性, 在概念上来说，和为整个变量赋值一个全新的结构体是等价的. 我们总是使用一个新的结构体, 并设置被改变的属性值, 然后用它替代原来的结构体. 而对于数组而言, 如果其中的元素是引用语义的实例(如类对象), 那么元素属性的变化 并不会对持有它的数组有什么影响, 然而如果元素是值语义的实例(值类型, 比如结构体), 那么当这个元素的属性发生改变时, 就会生成一个新的实例来替代该元素, 继而导致引用它的数组来生成一个新的实例数组代替.举个例子:1234567891011121314151617181920212223242526272829struct Node &#123; var value: Int = 0;&#125;class TestClass &#123; var nodes: [Node] = [] &#123; didSet &#123; print(nodes) &#125; &#125; func changeFirstNode(to value: Int) &#123; if nodes.count &gt; 0 &#123; nodes[0].value = value; &#125; &#125;&#125;let test = TestClass();// 创建一个nodes的数组赋值给test实例, 触发一次nodes的didSet// 输出内容为[Node(value: 0), Node(value: 1), Node(value: 2)]test.nodes = [Node(value: 0), Node(value: 1), Node(value: 2)]// 更改了数组中第0个node的value值, 由于node是结构体类型, 当其变量变化时, 为nodes[0]这个变量赋值了一个全新的结构体test.changeFirstNode(to: 5)// 而由于Array类型也是值类型, 所以也会生成一个全新的数组, 将self.nodes指向这个心的数组, 从而导致出发了nodes的didSet.// 此时会输出didSet中的打印: [Node(value: 5), Node(value: 1), Node(value: 2)]]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为泛型类型遵守协议添加类型约束]]></title>
    <url>%2F2017%2F06%2F25%2F%E4%B8%BA%E5%8D%8F%E8%AE%AE%E9%81%B5%E5%AE%88%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[分类中添加约束?例如, 有一个 Array&lt;SomeType&gt; 类型(Element 为 SomeType)的数组, 而我只想让这种类型的数组遵守 SomeProtocol 协议. 理想情况下, 应该这么写: 123456extension Array: SomeProtocol where Element : SomeType &#123; func someMethod() &#123; &#125;&#125; 但事实上并不能这么写, Xcode会报一个error:Extension of type &#39;Array&#39; with constraints cannot have an inheritance clause 声明中添加约束既然分类中不可以,那么对于自定义的类型, 在声明中就可行吗?如果是在声明中使用泛型的类型约束, 应该是这么写: 实现1234567891011class TestClass&lt;ObjectType&gt;: SomeProtocol where ObjectType : SomeType &#123; func testMethod() &#123; &#125;&#125;protocol SomeProtocol &#123; func testMethod();&#125; 编译通过, 测试下试试: 123let test1: TestClass&lt;String&gt;; // error: ❗️'TestClass' requires that 'String' inherit from 'NSObject'let test2: TestClass&lt;SomeType&gt;;test2.testMethod(); 缺点可以看到, 在声明中使用类型约束, 可以实现一定的效果, 但是这么操作有很大的局限性: 1. 不能对非自定义类型使用. 2. 会将泛型强制规定为这一类型. 较完美的方案难道就没有一种完美的实现方案吗?在电光石火间, 我抓住了灵感的一瞬: 实现123456789101112extension TestClass: SomeProtocol &#123; func testMethod() &#123; print("ObjectType isn't SomeType") &#125;&#125;extension TestClass where ObjectType : SomeType &#123; func testMethod() &#123; print("ObjectType is SomeType!"); &#125;&#125; test:12345let test1: TestClass&lt;NSObject&gt; = TestClass();let test2: TestClass&lt;SomeType&gt; = TestClass();test1.testMethod(); // ObjectType isn't SomeTypetest2.testMethod(); // ObjectType is SomeType! 缺点这个方案可以比较好的实现我们的需求, 唯一的缺点就是, 由于遵守协议时不能使用类型约束, 导致其他类型也可以使用协议内函数与变量. 相关stackoverflow上也有同学给出了另一种思路. 同时, Swift团队也把这项优化添加到了swift-evolution 中, 相信在 Swfit4 中就能看到: Generics improvements needed by the standard library.]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用bitfield优化代理方法的调用]]></title>
    <url>%2F2017%2F05%2F07%2F%E4%BD%BF%E7%94%A8bitfield%E4%BC%98%E5%8C%96%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言在编写 Objective-C 代码时, 代理 是我们经常使用的一种设计模式,它简单易用,善用它可令代码变的更易维护.然而,在对 代理对象 发送 protocol 中的消息时, 出于代码的健壮性的角度考虑, 我们都应该先去试探 代理对象 能否响应此消息:123if ([self.delegate conformsToProtocol:@protocol(SomeProtocol)] &amp;&amp; [self.delegate respondsToSelector:@selector(someProtocolMethod)]) &#123; [self.delegate someProtocolMethod];&#125; 注:苹果的大部分代理回调检验都只使用了[self.delegate respondsToSelector:@selector(someProtocolMethod)] ,例如 UITableView 的dataSource回调, 猜测这是苹果认为开发者对于一些基本的控件的接口都比较熟悉了, 一般不会发生在不知情的情况下就覆写掉 protocol 中的方法的场景, 然而, 当我们在定义自己的 protocol 并且调用其中方法时, 为了避免上述情况, 还是应该加上校验是否遵守了该 protocol 的判断. 然而, 当我们需要频繁的调用某个 protocol 中的方法时, 每次都进行如此判断合适吗? 仔细想想, 其实除了第一次的检测结果有用之外, 之后的校验判断可能多是多余的. 如果代理的对象没有发生改变, 那么极少情况下才会发生突然 遵守/不遵守 某个 protocol ,或者突然 响应/不响应 某个方法(比如在某些情景下利用 runtime 动态的遵守 protocol , 动态的添加/删除方法). 鉴于此, 我们可以使用一些手段来将这些信息缓存起来, 来避免多余/重复的判断. bitfield的使用使用 bitfield 这一数据类型可能是实现这种缓存的最佳方案了.我们可以利用 bitfield 声明结构体某个字段的所占用的二进制位数, 例如:12345struct Flags &#123; unsigned int flagA : 4; unsigned int flagB : 2; unsigned int flagC : 1;&#125;; 此时, 结构体 Flags 中, flagA 就占用了4个二进制位, flagB 与 flag 分别是2个和1个二进制位, 它们对应的存储范围分别是 0~15 , 0~3, 0~1.显然这里使用二级制位数为1的字段来作为调用代理方法的校验缓存再合适不过了. 如此 我们可以定义一个这样的结构体 12345struct SomeDelegateFlags &#123; unsigned int delgateMethodA : 1; unsigned int delgateMethodB : 1; unsigned int delgateMethodC : 1;&#125;; 在被委托对象中可以这么写:123456789101112131415161718192021222324252627282930313233// .h@interface SomeClass : SuperClass@property (nonatomic, weak) id&lt;SomeDelegate&gt; delegate;@end// .mstruct SomeDelegateFlags &#123; unsigned int delgateMethodA : 1; unsigned int delgateMethodB : 1; unsigned int delgateMethodC : 1;&#125;;typedef struct SomeDelegateFlags SomeDelegateFlags;@interface SomeClass ()@property (nonatomic, assign) SomeDelegateFlags delegateFlags;@end@implementation SomeClass- (void)setDelegate:(id&lt;SomeDelegate&gt;)delegate&#123; _delegate = delegate; if ([delegate conformsToProtocol:@protocol(SomeDelegate)]) &#123; _delegateFlags.delgateMethodA = [delegate respondsToSelector:@selector(delgateMethodA)]; _delegateFlags.delgateMethodB = [delegate respondsToSelector:@selector(delgateMethodB)]; _delegateFlags.delgateMethodC = [delegate respondsToSelector:@selector(delgateMethodC)]; &#125; else &#123; _delegateFlags.delgateMethodA = NO; _delegateFlags.delgateMethodB = NO; _delegateFlags.delgateMethodC = NO; &#125;&#125;@end 而在调用相关代理方法时, 就不需要再校验是否遵守协议,响应消息了,可以读取该结构体的字段的缓存值来进行判断了.123if (_delegateFlags.delegateMethodA) &#123; [_delegate delegateMethodA];&#125;]]></content>
      <tags>
        <tag>Objective-C</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[There was an internal API error问题的解决]]></title>
    <url>%2F2017%2F04%2F21%2FThere%20was%20an%20internal%20API%20error%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[今天用iOS7设备跑debug时发现app无法安装到设置上,并且Xcode会弹出一个显示 There was an internal API error. 错误的提示框. 搜了一圈发现几个可能因素: 工程中的 Product Name 是中文导致的.在Build Setting中搜索Product Name,修改成纯英文. Build Settings 中搜索 Packaging/Private Headers Folder Path 和 Product Module Name ,检查下名字是否为 Product Name 名. 试过以上两个之后 发现问题并没有解决, 于是我将 Main Scheme 的名字和 targetName 也改成英文,但没有起作用,然而此时, 运行项目最后报错12error: cannot parse the debug map for &quot;/Users/apple/Library/Developer/Xcode/DerivedData/xxx/your_app_name.app/your_app_name&quot;: Is a directory 看到这个之后, 我喜出望外, 进入到这个目录下, 发现确实存在 your_app_name 这个文件夹,而此文件夹是我们工程里的一个资源文件夹… 于是再次将 Product Name 修改为另一个英文名.随即运行通过. 总结工程的相关命名一定要规范: Product Name 要为英文, 避免上文中那种麻烦. 工程的名字最好为英文,同时名字中务必不要带空格. 此举是避免在 Search path 中会将空格转义为 \ ,因此导致一些文件无法被正确加载的问题. targetName , Scheme 的名字务必为英文. 虽然在上文中的问题与这俩并没有关系, 但是在之前我用 jenkins 构建自动部署的时候, 工程的 Workspace 的 Main Scheme 如果为中文的话, 总是会出现构建失败的问题, 虽然在之后的版本中 jenkins 已经没有了这个问题, 但是出于谨慎和规范起见, 这些名称都应该使用英文.]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[评论系统迁移Disqus及Next主题的一些配置优化]]></title>
    <url>%2F2017%2F04%2F15%2F%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E8%BF%81%E7%A7%BBDisqus%E5%8F%8ANext%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[迁移Disqus查看博客的时候发现多说将要关闭的消息,在几番选择下,就谋划将评论系统迁移到Disqus.然而喜出望外的是从jekyll迁移到Hexo之后还没有收到评论(无奈),所以此番迁移也不会费多少工夫. step 1修改next主题的配置文件_config.yml中关于disqus_shortname的设置,同时将duoshuo_shortname字段注释掉. 12# Disqusdisqus_shortname: your_disqus_shortname step 2打开next/layout/_partials/comments.swig文件找到这个判断条件1&#123;% elseif theme.disqus_shortname %&#125; ,在这个行下面将之前的占位的代码替换成我们所需要的,根据 Disqus 的指南,替换后的代码应该是这个样子的 12345678910111213141516171819&#123;% elseif theme.disqus_shortname %&#125; &lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt; &lt;script&gt; // RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. // LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ var disqus_config = function () &#123; this.page.url = &quot;&#123;&#123; page.permalink &#125;&#125;&quot;; // Replace PAGE_URL with your page&apos;s canonical URL variable this.page.identifier = &quot;&#123;&#123; page.path &#125;&#125;&quot;; // Replace PAGE_IDENTIFIER with your page&apos;s unique identifier variable &#125;; (function() &#123; // DON&apos;T EDIT BELOW THIS LINE var d = document, s = d.createElement(&apos;script&apos;); s.src = &apos;https://yourshortname.disqus.com/embed.js&apos;; s.setAttribute(&apos;data-timestamp&apos;, +new Date()); (d.head || d.body).appendChild(s); &#125;)(); &lt;/script&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; step 3保存更改的代码 在终端分别执行 hexo c, hexo g, hexo s. 进入一篇博客就可以看到熟悉的Disqus评论栏了. Next主题的一些配置优化在侧栏中显示其他社交平台的链接.以github为例: 123456social: Github: https://github.com/yourgithubsocial_icons: enable: true GitHub: github 侧栏头像设置:1avatar: your_acatar_picture_url 首页文章不显示全文123auto_excerpt:enable: truelength: 150 代码高亮:1highlight_theme: night //选一个自己喜欢的. 注意,代码高亮这样设置完了只是设置了代码高亮的主题, 想要在网页上显示高亮的效果,还需要自己在使用 ``` 生成代码区域时添加代码所属语言的标记,以OC为例:]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的计划]]></title>
    <url>%2F2017%2F03%2F05%2F%E6%96%B0%E7%9A%84%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[之前用jekyll 搭建的博客年久失修, 换了新本之后搭建环境又总是出问题, 索性换用了hexo,同时选用了next主题,感觉简洁多了. 在过去一年里的编程生涯中,虽然异常努力,但是感觉并没有达到自己预想的目标. 所以今年,我打算将重心放到研究优秀开源代码上.并完成一个优秀的开源框架,初步计划是一个图片选择/浏览器. 同时,我也要调整自己的作息. 由之前的 夜战 转为 日战, 早到公司俩小时, 多加俩小时班.将碎片的时间固集到一起. 希望自己能一直坚持如此,今年定是我的收获之年.]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC转Swift指南(二) 字符串和字符]]></title>
    <url>%2F2016%2F10%2F05%2FSwift%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%972-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Swift 的String和Character类型提供了快速和兼容 Unicode 的方式供你的代码使用。创建和操作字符串的语法与 C 语言中字符串操作相似，轻量并且易读。 字符串连接操作只需要简单地通过+符号将两个字符串相连即可。与 Swift 中其他值一样，能否更改字符串的值，取决于其被定义为常量还是变量。 注意：Swift 的String类型与 Foundation NSString类进行了无缝桥接。Foundation 也可以对String进行扩展，暴露在NSString中定义的方法。 这意味着，如果你在String中调用这些NSString的方法，将不用进行转换。更多关于在 Foundation 和 Cocoa 中使用String的信息请查看 _Using Swift with Cocoa and Objective-C (Swift 3.0.1)_。 初始化空字符串123var emptyString = "" // 空字符串字面量var anotherEmptyString = String() // 初始化方法// 两个字符串均为空并等价。 您可以通过检查其Bool类型的isEmpty属性来判断该字符串是否为空：1234if emptyString.isEmpty &#123; print("Nothing to see here")&#125;// 打印输出："Nothing to see here" 字符串可变性1234567var variableString = "Horse"variableString += " and carriage"// variableString 现在为 "Horse and carriage"let constantString = "Highlander"constantString += " and another Highlander"// 这会报告一个编译错误 (compile-time error) - 常量字符串不可以被修改。 字符串是值类型Swift 的String类型是值类型。 如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。 任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。 值类型在 结构体和枚举是值类型 中进行了详细描述。 Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。 很明显无论该值来自于哪里，都是您独自拥有的。 您可以确信传递的字符串不会被修改，除非你自己去修改它。 在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。 使用字符您可通过for-in循环来遍历字符串中的characters属性来获取每一个字符的值： 12345678for character in "Dog!🐶".characters &#123; print(character)&#125;// D// o// g// !// 🐶 另外，通过标明一个Character类型并用字符字面量进行赋值，可以建立一个独立的字符常量或变量：1let exclamationMark: Character = "!" 字符串可以通过传递一个值类型为Character的数组作为自变量来初始化：1234let catCharacters: [Character] = ["C", "a", "t", "!", "🐱"]let catString = String(catCharacters)print(catString)// 打印输出："Cat!🐱" 您可以用append()方法将一个字符附加到一个字符串变量的尾部：123let exclamationMark: Character = "!"welcome.append(exclamationMark)// welcome 现在等于 "hello there!"]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC转Swift指南(一) 基础部分]]></title>
    <url>%2F2016%2F10%2F03%2FSwift%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%971-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[简介这篇文章主要用于记录自己学习Swift的过程, 也为自己之后回顾时做个参考.文章是摘录自SwiftGG小组翻译的官方文档, 仅对文档内容中与Objective-C有差异的部分或比较重要的地方进行记录, 所以推荐具有Objective-C一年以上实际开发经验的阅读. 基础部分Swift 包含了 C 和 Objective-C 上的所有基础数据类型.Int表示整形.Double和Float表示浮点值.Bool是布尔型值.String的文本数据类型. 还有三个集合类型Array, Set, Dictionary. 声明常量和变量常量声明: let number = 10变量声明: var name = &quot;Lilei&quot;, var address: String也可以在一行中声明多个常量或者变量, 用,号隔开:var x = 0.0, y = 1.0, z = 2.0 类型标注var message: String: 表示给message变量添加了类型标注,message变量可以存储String类型的值.你也可以在一行中定义多个同样的变量. 用逗号分隔, 并在最后一个变量名之后添加类型标注:var red, green ,blue: Double 常量和变量的命名在 Swift 中, 你可以使用任何你喜欢的字符作为常量和变量名, 包括Unicode字符: 123let π = 3.14159let 哇偶 = "哈哈"let 🐮🐶 = "奶牛小狗" 除此之外 Swift 还支持使用 Swift 保留的关键字做变量名:1let `class` = 5 但是非常不推荐这么使用. 注意:以数字开头的命名仍然是不可取的. 输出常量和变量Swift 中使用 print() 作为输出函数. 12345678let name = "Lilei"print(name) // 输出 Lileilet age = 10print("age == \(age)") // 输出 age == 10. 将其他类型转成String类只需要用 \( ) 包裹就可以.print("The boy's name is " + name + "," + "he is " + "\(age)" + " years old"); //输出 The boy's name is Lilei,he is 10 years old. 可以使用 + 号拼接字符串. 类型安全和类型推断由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查(type checks), 并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误.当你在声明常量或者变量的时候赋给它们一个字面量(literal value 或 literal)即可触发类型推断 123let meaningOfLife = 42 // meaningOfLife 会被推测为 Int 类型let anotherPi = 3 + 0.14159 // anotherPi 会被推测为 Double 类型 数值型字面量123456789一个十进制数，没有前缀一个二进制数，前缀是0b一个八进制数，前缀是0o一个十六进制数，前缀是0xlet decimalInteger = 17let binaryInteger = 0b10001 // 二进制的17let octalInteger = 0o21 // 八进制的17let hexadecimalInteger = 0x11 // 十六进制的17 数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量： 123let paddedDouble = 000123.456let oneMillion = 1_000_000let justOverOneMillion = 1_000_000.000_000_1 整数转换1234let cannotBeNegative: UInt8 = -1// UInt8 类型不能存储负数，所以会报错let tooBig: Int8 = Int8.max + 1// Int8 类型不能存储超过最大值的数，所以会报错 要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。 123let ten: Int = 10;let half: Double = 0.5;let tenHalf = Double(ten) + half; // 将Int型的ten转换成Double类型 10.5; SomeType(ofInitialValue)是调用 Swift 构造器并传入一个初始值的默认方法. 你并不能传入任意类型的值，只能传入 SomeType 内部有对应构造器的值. 所以, 之所以我们可以使用 Double(IntValue) 将 Int 类型的常量转换成 Double, 是因为 Double 内部有该构造器. 你还可以扩展现有的类型来让它可以接收其他类型的值(包括自定义类型). 类型别名类型别名(type aliases)就是给现有类型定义另一个名字。你可以使用typealias关键字来定义类型别名.typealias AudioSample = UInt16 Bool值Swift 有一个基本的布尔(Boolean)类型，叫做Bool。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，true 和 false. 如果你在需要使用 Bool 类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：1234let i = 1if i &#123; // 这个例子不会通过编译，会报错&#125; 下面这个是合法的:1234let i = 1if i == 1 &#123; // 这个例子会编译成功&#125; 元祖元组(tuples)把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型. 12let http404Error = (404, "Not Found")// http404Error 的类型是 (Int, String)，值是 (404, "Not Found") 你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了： 12345let (statusCode, statusMessage) = http404Errorprint("The status code is \(statusCode)")// 输出 "The status code is 404"print("The status message is \(statusMessage)")// 输出 "The status message is Not Found" 如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线_标记： 123let (justTheStatusCode, _) = http404Errorprint("The status code is \(justTheStatusCode)")// 输出 "The status code is 404" 此外，你还可以通过下标来访问元组中的单个元素，下标从零开始: 1234print("The status code is \(http404Error.0)")// 输出 "The status code is 404"print("The status message is \(http404Error.1)")// 输出 "The status message is Not Found" 你可以在定义元组的时候给单个元素命名： 123456let http200Status = (statusCode: 200, description: "OK")//元组中的元素命名后，你可以通过名字来获取这些元素的值：print("The status code is \(http200Status.statusCode)")// 输出 "The status code is 200"print("The status message is \(http200Status.description)")// 输出 "The status message is OK" 注意：元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。 可选值C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回nil，nil表示”缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值(比如NSNotFound)来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断.然而,Swift 的可选类型可以让你暗示任意类型的值缺失，并不需要一个特殊值. 一个可选的 Int 被写作 Int? 而不是 Int.问号暗示包含的值是可选类型,也就是说可能包含 Int 值也可能不包含值. nilnil不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。 12345//如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nil：var surveyAnswer: String?// surveyAnswer 被自动设置为 nil` 注意: Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型. if 语句以及强制解析if判断不等:123if some != nil &#123; print("some is not nil")&#125; 当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号!来获取值。这个惊叹号表示”我知道这个可选有值，请使用它。”这被称为可选值的强制解析(forced unwrapping).123if some != nil &#123; print("some is not nil, is \(some!)")&#125; 注意: 使用 ! 来获取一个不存在的可选值会导致运行时错误。使用 ! 来强制解析值之前，一定要确定可选包含一个非 nil 的值. 可选绑定可选绑定可以用在 if 和 while 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量.12345if let actualNumber = Int(possibleNumber) &#123; print("\'\(possibleNumber)\' has an integer value of \(actualNumber)")&#125; else &#123; print("\'\(possibleNumber)\' could not be converted to an integer")&#125; 这段代码可以被理解为:“如果 Int(possibleNumber) 返回的可选 Int 包含一个值，创建一个叫做 actualNumber 的新常量并将可选包含的值赋给它。” 如果转换成功，actualNumber 常量可以在 if 语句的第一个分支中使用。它已经被可选类型 包含的 值初始化过，所以不需要再使用 ! 后缀来获取它的值。在这个例子中，actualNumber 只被用来输出转换结果。 你可以包含多个可选绑定或多个布尔条件在一个 if 语句中，只要使用逗号分开就行。只要有任意一个可选绑定的值为nil，或者任意一个布尔条件为false，则整个if条件判断为false，这时你就需要使用嵌套 if 条件语句来处理，如下所示：12345678910111213if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123; print("\(firstNumber) &lt; \(secondNumber) &lt; 100") &#125; // 输出 "4 &lt; 42 &lt; 100" if let firstNumber = Int("4") &#123; if let secondNumber = Int("42") &#123; if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123; print("\(firstNumber) &lt; \(secondNumber) &lt; 100") &#125; &#125; &#125; // 输出 "4 &lt; 42 &lt; 100" 注意： 在 if 条件语句中使用常量和变量来创建一个可选绑定，仅在 if 语句的句中(body)中才能获取到值。相反，在 guard 语句中使用常量和变量来创建一个可选绑定，仅在 guard 语句外且在语句后才能获取到值. 隐式解析可选类型如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过 if 语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。 有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。 这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型。 当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。隐式解析可选类型主要被用在 Swift 中类的构造过程中，请参考无主引用以及隐式解析可选属性。 一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型 String 和隐式解析可选类型 String 之间的区别：12345let possibleString: String? = "An optional string."let forcedString: String = possibleString! // 需要感叹号来获取值let assumedString: String! = "An implicitly unwrapped optional string."let implicitString: String = assumedString // 不需要感叹号 你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。 注意：如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。 如果一个变量之后可能变成nil的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是nil的话，请使用普通可选类型。 错误处理使用throws来标注函数会抛出异常.123func canThrowAnError() throws &#123; // 这个函数有可能抛出错误&#125; 当你的函数能抛出错误消息时, 你应该在表达式中前置try关键词。123456do &#123; try canThrowAnError() // 没有错误消息抛出&#125; catch &#123; // 有一个错误消息抛出&#125; 这里有一个错误处理如何用来应对不同错误条件的例子。123456789101112func makeASandwich() throws &#123; // ...&#125;do &#123; try makeASandwich() eatASandwich()&#125; catch SandwichError.outOfCleanDishes &#123; washDishes()&#125; catch SandwichError.missingIngredients(let ingredients) &#123; buyGroceries(ingredients)&#125; 在此例中，makeASandwich()函数会抛出一个错误消息,如果没有干净的盘子或者某个原料缺失。因为 makeASandwich() 抛出错误，函数调用被包裹在 try 表达式中。将函数包裹在一个 do 语句中，任何被抛出的错误会被传播到提供的 catch 从句中。 如果没有错误被抛出，eatASandwich() 函数会被调用。如果一个匹配 SandwichError.outOfCleanDishes 的错误被抛出，washDishes() 函数会被调用。如果一个匹配 SandwichError.missingIngredients 的错误被抛出，buyGroceries(_:) 函数会被调用，并且使用 catch 所捕捉到的关联值 [String] 作为参数。 基本预算符除了Objective-C原有的基本运算符外, Swift又新增了如下几个运算符 空合运算符（Nil Coalescing Operator）空合运算符（a ?? b）将对可选类型 a 进行空判断，如果 a 包含一个值就进行解封，否则就返回一个默认值 b。表达式 a 必须是 Optional 类型。默认值 b 的类型必须要和 a 存储值的类型保持一致。 a ?? b 就相当于 a != nil ? a! : b 区间运算符（Range Operators）Swift 提供了两个方便表达一个区间的值的区间运算符。 闭区间运算符闭区间运算符（a...b）定义一个包含从 a 到 b（包括 a 和 b）的所有值的区间。a 的值不能超过 b。12345678910111213141516171819202122for index in 1...5 &#123; print("\(index) * 5 = \(index * 5)")&#125;// 1 * 5 = 5// 2 * 5 = 10// 3 * 5 = 15// 4 * 5 = 20// 5 * 5 = 25``` #### 半开区间运算符半开区间运算符（`a..&lt;b`）定义一个从 `a` 到 `b` 但不包括 `b` 的区间。 之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。```Swiftlet names = ["Anna", "Alex", "Brian", "Jack"]let count = names.countfor i in 0..&lt;count &#123; print("第 \(i + 1) 个人叫 \(names[i])")&#125;// 第 1 个人叫 Anna// 第 2 个人叫 Alex// 第 3 个人叫 Brian// 第 4 个人叫 Jack]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
